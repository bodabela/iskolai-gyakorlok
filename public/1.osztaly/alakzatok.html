<!DOCTYPE html>
<html lang="hu">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>1. Osztály - Alakzatfelismerő</title>
    <style>
        body {
            font-family: 'Arial', sans-serif;
            margin: 0;
            padding: 20px;
            color: #333;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            transition: background-color 0.5s ease, color 0.5s ease;
        }

        .controls-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
            margin-bottom: 20px;
            padding: 10px;
            background-color: rgba(255, 255, 255, 0.9);
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.15);
            width: 100%;
            max-width: 900px;
        }

        .theme-selector {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 8px;
        }
        
        .control-label {
            font-weight: bold;
            margin-bottom: 5px;
            font-size: 0.95em;
            transition: color 0.5s ease;
        }
       
        .theme-button {
            padding: 8px 12px;
            border: 1px solid transparent;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            font-size: 0.9em;
            transition: background-color 0.3s ease, color 0.3s ease, border-color 0.3s ease, transform 0.2s ease;
        }
        .theme-button:hover {
            transform: translateY(-1px);
            opacity: 0.9;
        }
        .theme-button.active {
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.2), 0 0 0 2px var(--theme-button-active-border-color, #000); 
            transform: translateY(1px);
        }

        .container {
            background-color: #ffffff;
            padding: 20px; 
            border-radius: 12px;
            box-shadow: 0 6px 15px rgba(0,0,0,0.15);
            width: 100%;
            max-width: 900px; 
            text-align: center;
            transition: background-color 0.5s ease, border-color 0.5s ease;
        }
        
        h1, h2 {
            text-align: center;
            transition: color 0.5s ease;
        }
        h1 {
            font-size: clamp(1.8em, 5vw, 2.2em); 
            margin-bottom: 15px;
        }
        h2 {
            font-size: clamp(1.3em, 4vw, 1.6em); 
            margin-bottom: 25px;
        }
        .task {
            margin-bottom: 30px; 
            padding: 20px;
            border-radius: 10px;
            transition: background-color 0.5s ease, border-color 0.5s ease;
            border: 1px solid transparent; /* Alap keret, amit a témák felülírhatnak */
        }
        .task-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }
        .task-header h3 {
            margin-top: 0;
            margin-bottom: 0; 
            font-size: clamp(1.1em, 3.5vw, 1.3em); 
            transition: color 0.5s ease;
        }
        .new-task-button {
            padding: 6px 12px;
            font-size: 0.8em;
            margin-left: 10px; 
        }

        .task p.instructions { 
            line-height: 1.6; 
            font-size: clamp(1em, 3vw, 1.1em); 
            margin-bottom: 10px; 
            transition: color 0.5s ease;
        }
       
        button.task-button { 
            padding: 10px 20px; 
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: clamp(1em, 3vw, 1.1em); 
            transition: background-color 0.3s ease, transform 0.2s ease;
            margin-top: 10px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
        }
        button.task-button:hover {
            transform: translateY(-2px);
        }
        button.task-button:active {
            transform: translateY(0px);
        }
        .feedback {
            margin-top: 10px; 
            font-weight: bold;
            padding: 8px; 
            border-radius: 6px;
            font-size: clamp(0.9em, 2.8vw, 1.05em); 
            transition: color 0.5s ease, background-color 0.5s ease, border-color 0.5s ease;
            min-height: 1.5em; /* Hogy ne ugráljon az elrendezés */
        }
        .feedback.correct {
            color: var(--feedback-correct-text-color, #166534); /* green-800 */
            background-color: var(--feedback-correct-bg-color, #dcfce7); /* green-100 */
            border: 1px solid var(--feedback-correct-border-color, #4ade80); /* green-400 */
        }
        .feedback.incorrect {
            color: var(--feedback-incorrect-text-color, #991b1b); /* red-800 */
            background-color: var(--feedback-incorrect-bg-color, #fee2e2); /* red-100 */
            border: 1px solid var(--feedback-incorrect-border-color, #f87171); /* red-400 */
        }
        
        /* Alakzatfelismerő specifikus stílusok */
        .shape-display-area {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            align-items: center;
            gap: 20px;
            margin-bottom: 20px;
            min-height: 120px;
        }
        .shape-item, .shadow-item, .grouping-bin, .colorable-shape, .sequence-item-display {
            width: 80px;
            height: 80px;
            border: 2px solid transparent;
            border-radius: 8px;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            transition: transform 0.2s ease, border-color 0.3s ease, box-shadow 0.3s ease;
            user-select: none; 
            box-sizing: border-box;
        }
        .shape-item:hover, .shadow-item:hover, .colorable-shape:hover, .sequence-item-display:hover {
            transform: scale(1.05);
        }
        .shape-item svg, .shadow-item svg, .colorable-shape svg, .sequence-item-display svg {
            width: 90%;
            height: 90%;
        }
        .shape-item.selected { /* Általános kiválasztott stílus */
            border-color: var(--selected-item-border-color, #3b82f6) !important; /* Kék */
            box-shadow: 0 0 8px var(--selected-item-border-color, #3b82f6);
        }
        .shape-item.correct-connection, .shadow-item.correct-selection, .colorable-shape.correct-color, .sequence-item-display.correct-choice {
             border-color: var(--feedback-correct-border-color, green) !important;
        }
        .shape-item.incorrect-connection, .shadow-item.incorrect-selection, .colorable-shape.incorrect-color, .sequence-item-display.incorrect-choice  {
            border-color: var(--feedback-incorrect-border-color, red) !important;
        }
        
        .answer-options-container {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-top: 10px;
            flex-wrap: wrap;
        }
        .answer-option-button {
            padding: 10px 15px;
            font-size: 1em;
            border-radius: 6px;
            cursor: pointer;
            transition: background-color 0.3s, border-color 0.3s, color 0.3s;
            border: 1px solid #ccc;
        }
        .answer-option-button.selected {
            border-color: var(--selected-item-border-color, #3b82f6);
            background-color: var(--selected-item-bg-color, #bfdbfe); /* Light blue */
        }


        .connection-line-svg {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none; 
            z-index: 0; /* Alakzatok mögött, de a háttér felett */
        }
        .connection-line-svg line {
            stroke-width: 3px;
            transition: stroke 0.3s ease;
        }
        
        .grouping-container {
            display: flex;
            justify-content: space-around;
            align-items: flex-start; 
            margin-top: 20px;
            gap: 20px;
            min-height: 150px;
        }
        .grouping-bin {
            width: 120px;
            height: 120px;
            border: 2px dashed; 
            border-radius: 10px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            padding: 10px;
            box-sizing: border-box;
            font-weight: bold;
            background-color: rgba(0,0,0,0.02);
            transition: background-color 0.3s ease;
        }
        .grouping-bin.over { 
            background-color: rgba(0,0,0,0.08);
        }
        .grouped-item-placeholder { 
             width: 50px; height: 50px; border-radius: 4px; margin: 2px; background-color: #e0e0e0;
        }
        
        .color-palette {
            margin-top: 10px;
            margin-bottom: 15px;
            display: flex;
            justify-content: center;
            gap: 10px;
        }
        .color-palette-button {
            width: 30px;
            height: 30px;
            border-radius: 50%;
            border: 2px solid #ccc;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }
        .color-palette-button:hover {
            transform: scale(1.1);
        }
        .color-palette-button.selected-color {
            border-color: var(--selected-item-border-color, black) !important; 
            box-shadow: 0 0 5px 2px var(--selected-item-border-color, black);
        }

        .drawing-canvas-container {
            width: 250px;
            height: 200px;
            border: 2px solid; 
            margin: 15px auto;
            position: relative;
            background-color: #f9f9f9;
        }
        .drawing-canvas-container canvas {
            display: block;
        }

        .build-area-container {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            gap: 20px;
            margin-top: 15px;
        }
        .build-palette {
            display: flex;
            flex-direction: column;
            gap: 10px;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 8px;
            background-color: #f9f9f9;
        }
        .build-canvas {
            width: 300px;
            height: 250px;
            border: 2px dashed; 
            position: relative;
            background-color: #eef;
            border-radius: 8px;
        }
        .build-palette .shape-item {
            cursor: grab;
        }
        .build-palette .shape-item:active {
            cursor: grabbing;
        }
        .build-canvas .shape-item { 
             position: absolute; 
             cursor: move;
        }

        /* Téma specifikus CSS változók */
        :root {
            --body-bg-start: #e0f2fe; /* light blue */
            --body-bg-end: #f3e8ff;   /* light purple */
            --container-bg: #ffffff;
            --text-color: #333333;
            --h1-color: #3b82f6; /* blue-500 */
            --h2-color: #6366f1; /* indigo-500 */
            --task-bg: #f9fafb; /* gray-50 */
            --task-border: #e5e7eb; /* gray-200 */
            --task-header-color: #1f2937; /* gray-800 */
            --task-instruction-color: #4b5563; /* gray-600 */
            --button-bg: #3b82f6; /* blue-500 */
            --button-hover-bg: #2563eb; /* blue-600 */
            --theme-button-active-border-color: #60a5fa; /* blue-400 */
            --feedback-correct-text-color: #166534;
            --feedback-correct-bg-color: #dcfce7;
            --feedback-correct-border-color: #4ade80;
            --feedback-incorrect-text-color: #991b1b;
            --feedback-incorrect-bg-color: #fee2e2;
            --feedback-incorrect-border-color: #f87171;
            --selected-item-border-color: #3b82f6; /* blue */
            --selected-item-bg-color: #bfdbfe;  /* light blue for button bg */

            --shape-fill-default: #d1d5db; --shape-stroke-default: #6b7280;
            --shadow-fill-default: #a1a1aa;
            --bin-border-default: #9ca3af; --bin-text-default: #4b5563;
            --grouping-bin-bg: rgba(200,200,200,0.1);
            --draw-canvas-border: #a0aec0;
            --build-canvas-border: #a0aec0;
            --build-palette-bg: #f0f4f8;
            --connection-line-color: #6b7280;
        }

        body.theme-candy {
            --body-bg-start: #ffebf0; --body-bg-end: #ffe4e1;
            --container-bg: #fff0f5; --text-color: #5c3c4c;
            --h1-color: #ff69b4; --h2-color: #ff1493;
            --task-bg: #fffafa; --task-border: #ffb6c1;
            --task-header-color: #c71585; --task-instruction-color: #db7093;
            --button-bg: #ff69b4; --button-hover-bg: #ff1493;
            --theme-button-active-border-color: #ff85a2;
            --shape-fill-default: #ffc0cb; --shape-stroke-default: #ff69b4;
            --shadow-fill-default: #ffb6c1;
            --bin-border-default: #ffb6c1; --bin-text-default: #c71585;
            --grouping-bin-bg: rgba(255,182,193,0.2);
            --draw-canvas-border: #ffb6c1; --build-canvas-border: #ffb6c1; --build-palette-bg: #ffe4e1;
            --connection-line-color: #ff69b4;
            --selected-item-border-color: #ff1493; --selected-item-bg-color: #ffebf0;
        }
        body.theme-magicforest {
            --body-bg-start: #e6ffe6; --body-bg-end: #d4f0c4;
            --container-bg: #f0fff0; --text-color: #2e452a;
            --h1-color: #556b2f; --h2-color: #228b22;
            --task-bg: #f5fff5; --task-border: #90ee90;
            --task-header-color: #006400; --task-instruction-color: #3cb371;
            --button-bg: #2e8b57; --button-hover-bg: #3cb371;
            --theme-button-active-border-color: #66cdaa;
            --shape-fill-default: #d8bfd8; --shape-stroke-default: #9370db;
            --shadow-fill-default: #b0a0e0;
            --bin-border-default: #dda0dd; --bin-text-default: #8a2be2;
            --grouping-bin-bg: rgba(147,112,219,0.1);
            --draw-canvas-border: #9370db; --build-canvas-border: #9370db; --build-palette-bg: #e6e6fa;
            --connection-line-color: #9370db;
            --selected-item-border-color: #8a2be2; --selected-item-bg-color: #e9d8ff;
        }
        body.theme-ocean {
            --body-bg-start: #e0ffff; --body-bg-end: #afeeee;
            --container-bg: #f0ffff; --text-color: #005050;
            --h1-color: #20b2aa; --h2-color: #008080;
            --task-bg: #f5fffa; --task-border: #7fffd4;
            --task-header-color: #008080; --task-instruction-color: #48d1cc;
            --button-bg: #20b2aa; --button-hover-bg: #40e0d0;
            --theme-button-active-border-color: #5f9ea0;
            --shape-fill-default: #b2ebf2; --shape-stroke-default: #26a69a;
            --shadow-fill-default: #80deea;
            --bin-border-default: #4dd0e1; --bin-text-default: #00897b;
            --grouping-bin-bg: rgba(0,137,123,0.1);
            --draw-canvas-border: #26a69a; --build-canvas-border: #26a69a; --build-palette-bg: #e0f7fa;
            --connection-line-color: #26a69a;
             --selected-item-border-color: #00897b; --selected-item-bg-color: #b2ebf2;
        }
        body.theme-flowergarden {
            --body-bg-start: #fff8e1; --body-bg-end: #ffecb3;
            --container-bg: #fffaf0; --text-color: #6d4c41;
            --h1-color: #ff7043; --h2-color: #f4511e;
            --task-bg: #fffde7; --task-border: #ffd54f;
            --task-header-color: #e65100; --task-instruction-color: #ff8f00;
            --button-bg: #ff7043; --button-hover-bg: #ff8a65;
            --theme-button-active-border-color: #ffa726;
            --shape-fill-default: #ffe0b2; --shape-stroke-default: #fb8c00;
            --shadow-fill-default: #ffcc80;
            --bin-border-default: #ffb74d; --bin-text-default: #e65100;
            --grouping-bin-bg: rgba(230,81,0,0.1);
            --draw-canvas-border: #fb8c00; --build-canvas-border: #fb8c00; --build-palette-bg: #fff3e0;
            --connection-line-color: #fb8c00;
            --selected-item-border-color: #e65100; --selected-item-bg-color: #ffe0b2;
        }
        body.theme-sky {
            --body-bg-start: #e1f5fe; --body-bg-end: #b3e5fc;
            --container-bg: #f0f9ff; --text-color: #01579b;
            --h1-color: #03a9f4; --h2-color: #0288d1;
            --task-bg: #e3f2fd; --task-border: #81d4fa;
            --task-header-color: #01579b; --task-instruction-color: #039be5;
            --button-bg: #03a9f4; --button-hover-bg: #29b6f6;
            --theme-button-active-border-color: #4fc3f7;
            --shape-fill-default: #b3e5fc; --shape-stroke-default: #03a9f4;
            --shadow-fill-default: #81d4fa;
            --bin-border-default: #4fc3f7; --bin-text-default: #0288d1;
            --grouping-bin-bg: rgba(2,136,209,0.1);
            --draw-canvas-border: #03a9f4; --build-canvas-border: #03a9f4; --build-palette-bg: #e1f5fe;
            --connection-line-color: #03a9f4;
            --selected-item-border-color: #0288d1; --selected-item-bg-color: #b3e5fc;
        }
        body.theme-space {
            --body-bg-start: #2c3e50; --body-bg-end: #34495e;
            --container-bg: #1f2c38; --text-color: #ecf0f1;
            --h1-color: #3498db; --h2-color: #2980b9;
            --task-bg: #2c3a47; --task-border: #5d6d7e;
            --task-header-color: #bdc3c7; --task-instruction-color: #95a5a6;
            --button-bg: #3498db; --button-hover-bg: #5dade2;
            --theme-button-active-border-color: #85c1e9;
            --shape-fill-default: #4b5563; --shape-stroke-default: #9ca3af;
             --shadow-fill-default: #6b7280;
             --bin-border-default: #374151; --bin-text-default: #9ca3af;
             --grouping-bin-bg: rgba(55,65,81,0.2);
             --draw-canvas-border: #9ca3af; --build-canvas-border: #9ca3af; --build-palette-bg: #374151;
             --connection-line-color: #9ca3af;
             --selected-item-border-color: #3498db; --selected-item-bg-color: #4b5563;
        }
        body.theme-jungle {
            --body-bg-start: #38761d; --body-bg-end: #6aa84f;
            --container-bg: #2a531b; --text-color: #e8f5e9;
            --h1-color: #93c47d; --h2-color: #b6d7a8;
            --task-bg: #3a632cc7; --task-border: #799e6c;
            --task-header-color: #d9ead3; --task-instruction-color: #c9dfc0;
            --button-bg: #6aa84f; --button-hover-bg: #8fbc8f;
            --theme-button-active-border-color: #a9d18e;
            --shape-fill-default: #a7f3d0; --shape-stroke-default: #059669;
            --shadow-fill-default: #6ee7b7;
            --bin-border-default: #34d399; --bin-text-default: #047857;
            --grouping-bin-bg: rgba(4,120,87,0.1);
            --draw-canvas-border: #059669; --build-canvas-border: #059669; --build-palette-bg: #c8e6c9;
            --connection-line-color: #059669;
            --selected-item-border-color: #047857; --selected-item-bg-color: #a7f3d0;
        }
        body.theme-tech {
            --body-bg-start: #37474f; --body-bg-end: #546e7a;
            --container-bg: #263238; --text-color: #cfd8dc;
            --h1-color: #00bcd4; --h2-color: #00acc1;
            --task-bg: #303f46; --task-border: #546e7a;
            --task-header-color: #b0bec5; --task-instruction-color: #90a4ae;
            --button-bg: #00bcd4; --button-hover-bg: #26c6da;
            --theme-button-active-border-color: #4dd0e1;
            --shape-fill-default: #546e7a; --shape-stroke-default: #00acc1;
            --shadow-fill-default: #78909c;
            --bin-border-default: #455a64; --bin-text-default: #26c6da;
            --grouping-bin-bg: rgba(38,198,218,0.1);
            --draw-canvas-border: #00acc1; --build-canvas-border: #00acc1; --build-palette-bg: #37474f;
            --connection-line-color: #00acc1;
            --selected-item-border-color: #26c6da; --selected-item-bg-color: #546e7a;
        }
         body.theme-sport {
            --body-bg-start: #e3f2fd; --body-bg-end: #bbdefb;
            --container-bg: #f1f8e9; --text-color: #212121;
            --h1-color: #ff5722; --h2-color: #f44336;
            --task-bg: #fff; --task-border: #90caf9;
            --task-header-color: #0d47a1; --task-instruction-color: #1976d2;
            --button-bg: #4caf50; --button-hover-bg: #66bb6a;
            --theme-button-active-border-color: #81c784;
            --shape-fill-default: #90caf9; --shape-stroke-default: #1e88e5;
            --shadow-fill-default: #64b5f6;
            --bin-border-default: #42a5f5; --bin-text-default: #1976d2;
            --grouping-bin-bg: rgba(25,118,210,0.1);
            --draw-canvas-border: #1e88e5; --build-canvas-border: #1e88e5; --build-palette-bg: #e3f2fd;
            --connection-line-color: #1e88e5;
            --selected-item-border-color: #1976d2; --selected-item-bg-color: #90caf9;
        }
        body.theme-adventure {
            --body-bg-start: #efebe9; --body-bg-end: #d7ccc8;
            --container-bg: #f5f5f5; --text-color: #3e2723;
            --h1-color: #8d6e63; --h2-color: #795548;
            --task-bg: #fafafa; --task-border: #a1887f;
            --task-header-color: #4e342e; --task-instruction-color: #6d4c41;
            --button-bg: #795548; --button-hover-bg: #8d6e63;
            --theme-button-active-border-color: #a1887f;
            --shape-fill-default: #bcaaa4; --shape-stroke-default: #795548;
            --shadow-fill-default: #a1887f;
            --bin-border-default: #8d6e63; --bin-text-default: #5d4037;
            --grouping-bin-bg: rgba(93,64,55,0.1);
            --draw-canvas-border: #795548; --build-canvas-border: #795548; --build-palette-bg: #efebe9;
            --connection-line-color: #795548;
            --selected-item-border-color: #5d4037; --selected-item-bg-color: #bcaaa4;
        }

        .colorable-shape.colored-by-user {
            /* A JS állítja be a fill színt a palettáról */
        }

        /* Általános stílusok a témaváltó gombokhoz */
        .theme-button {
            background-color: var(--task-bg);
            color: var(--task-header-color);
            border: 1px solid var(--task-border);
        }
        .theme-button:hover {
            opacity: 1;
            background-color: var(--task-border);
        }
        .theme-button.active {
            background-color: var(--button-bg);
            color: white;
            border-color: var(--button-bg);
             box-shadow: inset 0 1px 3px rgba(0,0,0,0.2), 0 0 0 2px var(--theme-button-active-border-color);
        }

        /* Gombok stílusa a téma alapján */
        button.task-button, button.new-task-button {
            background-color: var(--button-bg);
            color: white; /* Általában fehér a gomb szövege */
        }
        button.task-button:hover, button.new-task-button:hover {
            background-color: var(--button-hover-bg);
        }

        /* Input mezők, ha lennének */
        input[type="text"], input[type="number"] {
            border: 1px solid var(--task-border);
            background-color: var(--container-bg);
            color: var(--text-color);
            padding: 8px;
            border-radius: 4px;
        }
        input[type="text"]:focus, input[type="number"]:focus {
            border-color: var(--button-bg);
            box-shadow: 0 0 0 2px var(--theme-button-active-border-color);
            outline: none;
        }

        /* Választógombok (pl. alakzat neve) */
        .answer-option-button {
             background-color: var(--task-bg);
             color: var(--task-instruction-color);
             border: 1px solid var(--task-border);
        }
        .answer-option-button:hover {
            border-color: var(--button-hover-bg);
            background-color: var(--task-border);
        }
        .answer-option-button.selected {
            background-color: var(--selected-item-bg-color);
            color: var(--button-bg);
            border-color: var(--selected-item-border-color);
            font-weight: bold;
        }


    </style>
</head>
<body> <div class="controls-container">
        <div>
            <p class="control-label">Téma választó:</p>
            <div class="theme-selector">
                <button class="theme-button" data-theme="theme-candy">Cukorka</button>
                <button class="theme-button" data-theme="theme-magicforest">Varázserdő</button>
                <button class="theme-button" data-theme="theme-ocean">Óceán</button>
                <button class="theme-button" data-theme="theme-flowergarden">Virágoskert</button>
                <button class="theme-button" data-theme="theme-sky">Égbolt</button>
                <button class="theme-button" data-theme="theme-space">Űr</button>
                <button class="theme-button" data-theme="theme-jungle">Őserdő</button>
                <button class="theme-button" data-theme="theme-tech">Techno</button>
                <button class="theme-button" data-theme="theme-sport">Sport</button>
                <button class="theme-button" data-theme="theme-adventure">Kaland</button>
                 <button class="theme-button" data-theme="default">Alapértelmezett</button>
            </div>
        </div>
    </div>

    <div class="container">
        <h1>Alakzatfelismerő Feladatok</h1>
        <h2>1. Osztály</h2>

        <div class="task" id="task1_connect_shapes">
            <div class="task-header">
                <h3 style="color: var(--task-header-color);">1. Feladat: Kösd össze az egyformákat!</h3>
                <button class="task-button new-task-button" onclick="generateTask1()">Új feladat</button>
            </div>
            <p class="instructions" style="color: var(--task-instruction-color);">Húzd a vonalat az összetartozó alakzatok között! (Kattints az elsőre, majd a másodikra.)</p>
            <div class="shape-display-area" id="connect_shapes_area" style="position: relative;">
                <svg class="connection-line-svg" id="connection_lines_svg_task1"></svg>
                <div id="connect_col1" style="display: flex; flex-direction: column; gap: 15px; z-index: 1;"></div>
                <div id="connect_col2" style="display: flex; flex-direction: column; gap: 15px; z-index: 1;"></div>
            </div>
            <button class="task-button" onclick="checkTask1()">Ellenőrzés</button>
            <p id="feedback_task1" class="feedback"></p>
        </div>

        <div class="task" id="task2_find_shadow">
            <div class="task-header">
                <h3 style="color: var(--task-header-color);">2. Feladat: Keresd az árnyékát!</h3>
                <button class="task-button new-task-button" onclick="generateTask2()">Új feladat</button>
            </div>
            <p class="instructions" style="color: var(--task-instruction-color);">Melyik árnyék tartozik a színes alakzathoz? Kattints a helyes árnyékra!</p>
            <div style="display: flex; justify-content: center; align-items: center; gap: 30px; margin-bottom: 20px;">
                <div class="shape-item" id="shadow_original_shape_display"></div>
            </div>
            <div class="shape-display-area" id="shadow_options_area"></div>
            <button class="task-button" onclick="checkTask2()">Ellenőrzés</button>
            <p id="feedback_task2" class="feedback"></p>
        </div>
        
        <div class="task" id="task3_group_shapes">
            <div class="task-header">
                <h3 style="color: var(--task-header-color);">3. Feladat: Hova tartozik?</h3>
                <button class="task-button new-task-button" onclick="generateTask3()">Új feladat</button>
            </div>
            <p class="instructions" style="color: var(--task-instruction-color);">Húzd az alakzatokat a megfelelő dobozba!</p>
            <div class="shape-display-area" id="grouping_draggable_shapes_area" style="margin-bottom: 30px; min-height:90px;">
                </div>
            <div class="grouping-container">
                <div class="grouping-bin" id="grouping_bin_1" data-shape-type="kor" style="border-color: var(--bin-border-default); color: var(--bin-text-default); background-color: var(--grouping-bin-bg);">KÖRÖK</div>
                <div class="grouping-bin" id="grouping_bin_2" data-shape-type="negyzet" style="border-color: var(--bin-border-default); color: var(--bin-text-default); background-color: var(--grouping-bin-bg);">NÉGYZETEK</div>
                <div class="grouping-bin" id="grouping_bin_3" data-shape-type="haromszog" style="border-color: var(--bin-border-default); color: var(--bin-text-default); background-color: var(--grouping-bin-bg);">HÁROMSZÖGEK</div>
            </div>
            <button class="task-button" onclick="checkTask3()">Ellenőrzés</button>
            <p id="feedback_task3" class="feedback"></p>
        </div>

        <div class="task" id="task4_odd_one_out">
            <div class="task-header">
                <h3 style="color: var(--task-header-color);">4. Feladat: Melyik nem illik a sorba?</h3>
                <button class="task-button new-task-button" onclick="generateTask4()">Új feladat</button>
            </div>
            <p class="instructions" style="color: var(--task-instruction-color);">Kattints arra az alakzatra, amelyik nem illik a többi közé!</p>
            <div class="shape-display-area" id="odd_one_out_area"></div>
            <button class="task-button" onclick="checkTask4()">Ellenőrzés</button>
            <p id="feedback_task4" class="feedback"></p>
        </div>

        <div class="task" id="task5_continue_sequence">
            <div class="task-header">
                <h3 style="color: var(--task-header-color);">5. Feladat: Folytasd a sort!</h3>
                <button class="task-button new-task-button" onclick="generateTask5()">Új feladat</button>
            </div>
            <p class="instructions" style="color: var(--task-instruction-color);">Figyeld meg a sorozatot! Melyik alakzat következik? Húzd a helyére, vagy kattints rá!</p>
            <div style="display: flex; flex-direction: column; align-items: center; gap: 20px;">
                <div class="shape-display-area" id="sequence_display_area" style="border-bottom: 2px solid var(--task-border); padding-bottom: 10px;">
                    </div>
                <div class="shape-item" id="sequence_drop_target" style="border: 2px dashed var(--task-border); width: 85px; height: 85px; font-size: 2em; color: var(--task-instruction-color);">?</div>
                <div class="shape-display-area" id="sequence_options_area" style="margin-top: 15px;">
                    </div>
            </div>
            <button class="task-button" onclick="checkTask5()">Ellenőrzés</button>
            <p id="feedback_task5" class="feedback"></p>
        </div>
        
        <div class="task" id="task7_identify_shape">
            <div class="task-header">
                <h3 style="color: var(--task-header-color);">7. Feladat: Mi ez az alakzat?</h3>
                <button class="task-button new-task-button" onclick="generateTask7()">Új feladat</button>
            </div>
            <p class="instructions" style="color: var(--task-instruction-color);">Kattints az alakzat helyes megnevezésére!</p>
            <div class="shape-display-area" id="identify_shape_display_area">
                </div>
            <div class="answer-options-container" id="identify_answer_options">
                </div>
            <button class="task-button" onclick="checkTask7()">Ellenőrzés</button>
            <p id="feedback_task7" class="feedback"></p>
        </div>

        <div class="task" id="task8_color_shapes">
            <div class="task-header">
                <h3 style="color: var(--task-header-color);">8. Feladat: Színezd ki!</h3>
                <button class="task-button new-task-button" onclick="generateTask8()">Új feladat</button>
            </div>
            <p class="instructions" id="color_task_instruction" style="color: var(--task-instruction-color);">Válaszd ki a színt, majd kattints azokra az alakzatokra, amiket ki szeretnél színezni!</p>
            <div class="color-palette" id="color_palette_task8"></div>
            <div class="shape-display-area" id="coloring_shapes_area"></div>
            <button class="task-button" onclick="checkTask8()">Ellenőrzés</button>
            <p id="feedback_task8" class="feedback"></p>
        </div>
        
        <div class="task" id="task9_draw_half">
            <div class="task-header">
                <h3 style="color: var(--task-header-color);">9. Feladat: Rajzold meg a hiányzó felét!</h3>
                <button class="task-button new-task-button" onclick="generateTask9()">Új feladat</button>
            </div>
            <p class="instructions" style="color: var(--task-instruction-color);">Rajzold meg az alakzat tükörképét a szaggatott vonalra! (Kattints és húzd a vásznon.)</p>
            <div class="drawing-canvas-container" id="draw_half_canvas_container_task9" style="border-color: var(--draw-canvas-border);">
                <canvas id="draw_half_canvas_task9"></canvas>
            </div>
            <button class="task-button" onclick="checkTask9()">Ellenőrzés (Manuális)</button>
            <button class="task-button" onclick="clearCanvasTask9()" style="margin-left: 10px;">Radír</button>
            <p id="feedback_task9" class="feedback"></p>
        </div>
        
        <div class="task" id="task10_build_with_shapes">
            <div class="task-header">
                <h3 style="color: var(--task-header-color);">10. Feladat: Építs házikót!</h3>
                <button class="task-button new-task-button" onclick="generateTask10()">Új feladat</button>
            </div>
            <p class="instructions" style="color: var(--task-instruction-color);">Húzd az alakzatokat a helyükre, hogy megépítsd a házikót!</p>
            <div class="build-area-container">
                <div class="build-palette" id="build_palette_task10" style="border-color: var(--task-border); background-color: var(--build-palette-bg);">
                    </div>
                <div class="build-canvas" id="build_canvas_task10" style="border-color: var(--build-canvas-border); background-color: var(--build-palette-bg);">
                    </div>
            </div>
            <button class="task-button" onclick="checkTask10()">Ellenőrzés</button>
            <p id="feedback_task10" class="feedback"></p>
        </div>

    </div>

    <script>
const bodyEl = document.body;
        const themeButtons = document.querySelectorAll('.theme-button');
        let currentTheme = localStorage.getItem('alakzatokPageTheme') || 'theme-candy';

        function applyTheme(themeClass) {
            bodyEl.className = '';
            if (themeClass !== 'default') {
                 bodyEl.classList.add(themeClass);
            }
            currentTheme = themeClass;
            localStorage.setItem('alakzatokPageTheme', themeClass);

            themeButtons.forEach(btn => {
                btn.classList.toggle('active', btn.dataset.theme === themeClass);
            });
            
            const styles = getComputedStyle(document.body);
            document.documentElement.style.setProperty('--current-body-bg-start', styles.getPropertyValue('--body-bg-start').trim());
            document.documentElement.style.setProperty('--current-body-bg-end', styles.getPropertyValue('--body-bg-end').trim());
            document.body.style.background = `linear-gradient(to bottom right, var(--current-body-bg-start), var(--current-body-bg-end))`;
            
            document.querySelector('.container').style.backgroundColor = styles.getPropertyValue('--container-bg').trim();
            document.body.style.color = styles.getPropertyValue('--text-color').trim();
            // Biztosítjuk, hogy a H1 és H2 elemek léteznek, mielőtt stílusukat állítanánk
            const h1El = document.querySelector('h1');
            if (h1El) h1El.style.color = styles.getPropertyValue('--h1-color').trim();
            const h2El = document.querySelector('h2');
            if (h2El) h2El.style.color = styles.getPropertyValue('--h2-color').trim();


            document.querySelectorAll('.task').forEach(task => {
                task.style.backgroundColor = styles.getPropertyValue('--task-bg').trim();
                task.style.borderColor = styles.getPropertyValue('--task-border').trim();
            });
            
            const isThemeChange = true;
            if (typeof generateTask1 === 'function') try { generateTask1(isThemeChange); } catch(e){console.warn("Hiba T1 újragenerálásakor:",e)}
            if (typeof generateTask2 === 'function') try { generateTask2(isThemeChange); } catch(e){console.warn("Hiba T2 újragenerálásakor:",e)}
            if (typeof generateTask3 === 'function') try { generateTask3(isThemeChange); } catch(e){console.warn("Hiba T3 újragenerálásakor:",e)}
            if (typeof generateTask4 === 'function') try { generateTask4(isThemeChange); } catch(e){console.warn("Hiba T4 újragenerálásakor:",e)}
            if (typeof generateTask5 === 'function') try { generateTask5(isThemeChange); } catch(e){console.warn("Hiba T5 újragenerálásakor:",e)}
            if (typeof generateTask7 === 'function') try { generateTask7(isThemeChange); } catch(e){console.warn("Hiba T7 újragenerálásakor:",e)}
            if (typeof generateTask8 === 'function') try { generateTask8(isThemeChange); } catch(e){console.warn("Hiba T8 újragenerálásakor:",e)}
            if (typeof generateTask9 === 'function') try { generateTask9(isThemeChange); } catch(e){console.warn("Hiba T9 újragenerálásakor:",e)}
            if (typeof generateTask10 === 'function') try { generateTask10(isThemeChange); } catch(e){console.warn("Hiba T10 újragenerálásakor:",e)}
        }

        themeButtons.forEach(button => {
            button.addEventListener('click', () => {
                applyTheme(button.dataset.theme);
            });
        });
        
        const SVG_NS = "http://www.w3.org/2000/svg";
        const ALL_SHAPE_TYPES = ["kor", "negyzet", "haromszog", "teglalap"];

        function getThemeColor(variableName, fallbackColor) {
            const color = getComputedStyle(document.body).getPropertyValue(variableName).trim();
            return color || fallbackColor;
        }

        function createShapeSvg(type, size = 60, options = {}) {
            const svg = document.createElementNS(SVG_NS, "svg");
            svg.setAttribute("viewBox", `0 0 ${size} ${size}`);
            svg.setAttribute("width", size);
            svg.setAttribute("height", size);
            
            const strokeWidth = options.strokeWidth || Math.max(1, size * 0.035); 
            
            const defaultFill = getThemeColor('--shape-fill-default', '#d1d5db');
            const defaultStroke = getThemeColor('--shape-stroke-default', '#6b7280');
            const shadowFill = getThemeColor('--shadow-fill-default', '#a1a1aa');

            const currentFill = options.isShadow ? shadowFill : (options.fill || defaultFill);
            const currentStroke = options.isShadow ? "none" : (options.stroke || defaultStroke);

            let shapeEl;
            switch (type) {
                case "kor":
                case "golyo_kor":
                    shapeEl = document.createElementNS(SVG_NS, "circle");
                    shapeEl.setAttribute("cx", size / 2);
                    shapeEl.setAttribute("cy", size / 2);
                    shapeEl.setAttribute("r", Math.max(1, size / 2 - strokeWidth / 2));
                    break;
                case "negyzet":
                case "kocka_lap":
                    shapeEl = document.createElementNS(SVG_NS, "rect");
                    shapeEl.setAttribute("x", strokeWidth / 2);
                    shapeEl.setAttribute("y", strokeWidth / 2);
                    shapeEl.setAttribute("width", Math.max(1, size - strokeWidth));
                    shapeEl.setAttribute("height", Math.max(1, size - strokeWidth));
                    shapeEl.setAttribute("rx", size * 0.05); 
                    break;
                case "haromszog": 
                    shapeEl = document.createElementNS(SVG_NS, "polygon");
                    const side = size - strokeWidth;
                    const triangleHeight = (Math.sqrt(3) / 2) * side;
                    const topY = (size - triangleHeight) / 2 + strokeWidth / 2;
                    const bottomY = topY + triangleHeight - strokeWidth/2;
                    const leftX = strokeWidth / 2;
                    const rightX = size - strokeWidth / 2;
                    shapeEl.setAttribute("points", `${size/2},${topY} ${leftX},${bottomY} ${rightX},${bottomY}`);
                    break;
                case "teglalap":
                    shapeEl = document.createElementNS(SVG_NS, "rect");
                    shapeEl.setAttribute("x", strokeWidth / 2);
                    shapeEl.setAttribute("y", size * 0.25 + strokeWidth / 2);
                    shapeEl.setAttribute("width", Math.max(1, size - strokeWidth));
                    shapeEl.setAttribute("height", Math.max(1, size * 0.5 - strokeWidth));
                    shapeEl.setAttribute("rx", size * 0.05);
                    break;
                 default: // Ha ismeretlen típus, egy üres placeholder
                    shapeEl = document.createElementNS(SVG_NS, "rect");
                    shapeEl.setAttribute("x", strokeWidth / 2);
                    shapeEl.setAttribute("y", strokeWidth / 2);
                    shapeEl.setAttribute("width", Math.max(1, size - strokeWidth));
                    shapeEl.setAttribute("height", Math.max(1, size - strokeWidth));
                    shapeEl.setAttribute("fill", "transparent");
                    shapeEl.setAttribute("stroke", getThemeColor('--task-border', '#ccc'));
                    shapeEl.setAttribute("stroke-dasharray","4 2");
            }
            if (shapeEl) {
                shapeEl.setAttribute("fill", currentFill);
                shapeEl.setAttribute("stroke", currentStroke);
                shapeEl.setAttribute("stroke-width", strokeWidth);
                if (options.transform) shapeEl.setAttribute("transform", options.transform);
                svg.appendChild(shapeEl);
            }
            return svg;
        }
        
        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
            return array;
        }

        function clearFeedback(feedbackElId) {
            const el = document.getElementById(feedbackElId);
            if (el) {
                el.innerHTML = '';
                el.className = 'feedback';
            }
        }
        
        function setFeedback(feedbackElId, message, isCorrect) {
            const el = document.getElementById(feedbackElId);
            if (el) {
                el.innerHTML = message; 
                el.className = `feedback ${isCorrect ? 'correct' : 'incorrect'}`;
                 if (isCorrect) {
                    setTimeout(() => {
                         if(el.classList.contains('correct')) { 
                             el.innerHTML = '';
                             el.className = 'feedback';
                         }
                    }, 3000);
                }
            }
        }

        let draggedElement = null;
        let draggedElementData = null; // Store data of the dragged element

        function makeDraggable(element, data) {
            element.draggable = true;
            element.style.cursor = 'grab';
            element.addEventListener('dragstart', (event) => {
                draggedElement = element; // The HTML element itself
                draggedElementData = data || { type: element.dataset.shapeType, id: element.id, originalParentId: element.parentElement.id };
                event.dataTransfer.setData('text/plain', JSON.stringify(draggedElementData));
                event.dataTransfer.effectAllowed = 'move';
                element.style.opacity = '0.5';
                element.classList.add('dragging');
            });
            element.addEventListener('dragend', (event) => {
                element.style.opacity = '1';
                element.style.cursor = 'grab';
                element.classList.remove('dragging');
                // Do not nullify draggedElementData here if it's used by the drop handler
                // It will be nullified after a successful drop by the drop handler or if drop fails
            });
        }

        function makeDroppable(element, onDropCallback) {
            element.addEventListener('dragover', (event) => {
                event.preventDefault(); 
                event.dataTransfer.dropEffect = 'move';
                element.classList.add('over');
            });
            element.addEventListener('dragleave', () => {
                element.classList.remove('over');
            });
            element.addEventListener('drop', (event) => {
                event.preventDefault();
                element.classList.remove('over');
                const data = JSON.parse(event.dataTransfer.getData('text/plain'));
                if (draggedElement && data) { 
                    onDropCallback(draggedElement, element, data); // Pass the HTML element and its data
                }
                draggedElement = null; // Clear after drop attempt
                draggedElementData = null;
            });
        }
        
        // --- Feladat 1: Kösd össze az egyformákat! ---
        // (Már implementálva az előző válaszban, itt változatlanul hagyom)
        let task1State = {}; 
        function generateTask1(isThemeChange = false) {
            if (!isThemeChange) clearFeedback('feedback_task1');
            const col1Container = document.getElementById('connect_col1');
            const col2Container = document.getElementById('connect_col2');
            const svgLinesContainer = document.getElementById('connection_lines_svg_task1');
            col1Container.innerHTML = '';
            col2Container.innerHTML = '';
            svgLinesContainer.innerHTML = ''; 

            const availableShapes = ["kor", "negyzet", "haromszog", "teglalap"];
            let baseShapes = [];
            for(let i=0; i<3; i++){ 
                baseShapes.push(availableShapes[Math.floor(Math.random() * availableShapes.length)]);
            }

            let column1ShapesData = [...baseShapes];
            let column2ShapesData = [...baseShapes];
            shuffleArray(column1ShapesData);
            shuffleArray(column2ShapesData);

            task1State = {
                col1: [],
                col2: [],
                connections: [], 
                selectedShape: null,
                mapCol1: column1ShapesData,
                mapCol2: column2ShapesData
            };
            const shapeSize = 65;
            column1ShapesData.forEach((type, index) => {
                const shapeDiv = document.createElement('div');
                shapeDiv.classList.add('shape-item');
                shapeDiv.dataset.shapeType = type;
                shapeDiv.dataset.id = `t1_col1_${index}`;
                const svg = createShapeSvg(type, shapeSize);
                shapeDiv.appendChild(svg);
                shapeDiv.addEventListener('click', () => handleShapeConnectClickTask1(shapeDiv));
                col1Container.appendChild(shapeDiv);
                task1State.col1.push(shapeDiv);
            });
            column2ShapesData.forEach((type, index) => {
                const shapeDiv = document.createElement('div');
                shapeDiv.classList.add('shape-item');
                shapeDiv.dataset.shapeType = type;
                shapeDiv.dataset.id = `t1_col2_${index}`;
                const svg = createShapeSvg(type, shapeSize);
                shapeDiv.appendChild(svg);
                shapeDiv.addEventListener('click', () => handleShapeConnectClickTask1(shapeDiv));
                col2Container.appendChild(shapeDiv);
                task1State.col2.push(shapeDiv);
            });
        }
        function handleShapeConnectClickTask1(shapeDiv) {
            const feedbackEl = document.getElementById('feedback_task1');
            const svgLinesContainer = document.getElementById('connection_lines_svg_task1');
            const mainConnectArea = document.getElementById('connect_shapes_area');
            if (!mainConnectArea) return;
            const mainContainerRect = mainConnectArea.getBoundingClientRect();
            task1State.col1.forEach(s => s.classList.remove('correct-connection', 'incorrect-connection','selected'));
            task1State.col2.forEach(s => s.classList.remove('correct-connection', 'incorrect-connection','selected'));

            const existingConnectionIndex = task1State.connections.findIndex(conn => conn.from === shapeDiv || conn.to === shapeDiv);
            if (existingConnectionIndex !== -1) {
                const removedConn = task1State.connections.splice(existingConnectionIndex, 1)[0];
                if (removedConn && removedConn.line) removedConn.line.remove();
                if (task1State.selectedShape === shapeDiv) task1State.selectedShape = null;
                shapeDiv.classList.remove('selected');
                clearFeedback('feedback_task1');
                if (removedConn) {
                    const partner = removedConn.from === shapeDiv ? removedConn.to : removedConn.from;
                    partner.classList.remove('selected');
                }
                return;
            }

            if (!task1State.selectedShape) {
                shapeDiv.classList.add('selected');
                task1State.selectedShape = shapeDiv;
                setFeedback('feedback_task1', "Válassz egy párt a másik oszlopból.", false);
            } else {
                if (task1State.selectedShape === shapeDiv) { 
                    task1State.selectedShape.classList.remove('selected');
                    task1State.selectedShape = null;
                    clearFeedback('feedback_task1');
                    return;
                }
                const isSelectedFromCol1 = task1State.col1.includes(task1State.selectedShape);
                const isCurrentFromCol2 = task1State.col2.includes(shapeDiv);
                const isSelectedFromCol2 = task1State.col2.includes(task1State.selectedShape);
                const isCurrentFromCol1 = task1State.col1.includes(shapeDiv);

                if (!((isSelectedFromCol1 && isCurrentFromCol2) || (isSelectedFromCol2 && isCurrentFromCol1))) {
                    setFeedback('feedback_task1', "Kérlek, a másik oszlopból válassz párt!", false);
                    return;
                }
                const line = document.createElementNS(SVG_NS, 'line');
                const rect1 = task1State.selectedShape.getBoundingClientRect();
                const rect2 = shapeDiv.getBoundingClientRect();
                const x1 = rect1.left + rect1.width / 2 - mainContainerRect.left;
                const y1 = rect1.top + rect1.height / 2 - mainContainerRect.top;
                const x2 = rect2.left + rect2.width / 2 - mainContainerRect.left;
                const y2 = rect2.top + rect2.height / 2 - mainContainerRect.top;
                line.setAttribute('x1', x1); line.setAttribute('y1', y1);
                line.setAttribute('x2', x2); line.setAttribute('y2', y2);
                line.style.stroke = getThemeColor('--connection-line-color', '#6b7280');
                line.style.strokeWidth = '3';
                svgLinesContainer.appendChild(line);
                task1State.connections.push({ from: task1State.selectedShape, to: shapeDiv, line: line });
                task1State.selectedShape.classList.remove('selected');
                task1State.selectedShape = null;
                clearFeedback('feedback_task1');
            }
        }
        function checkTask1() {
            clearFeedback('feedback_task1');
            if (task1State.connections.length === 0) {
                setFeedback('feedback_task1', "Kérlek, köss össze legalább egy párt!", false); return;
            }
            let correctConnectionsCount = 0;
            const totalPossiblePairs = task1State.col1.length; 
            task1State.connections.forEach(conn => {
                const type1 = conn.from.dataset.shapeType;
                const type2 = conn.to.dataset.shapeType;
                conn.from.classList.remove('correct-connection', 'incorrect-connection');
                conn.to.classList.remove('correct-connection', 'incorrect-connection');
                if (type1 === type2) {
                    correctConnectionsCount++;
                    conn.line.style.stroke = getThemeColor('--feedback-correct-border-color', 'green');
                    conn.from.classList.add('correct-connection');
                    conn.to.classList.add('correct-connection');
                } else {
                    conn.line.style.stroke = getThemeColor('--feedback-incorrect-border-color', 'red');
                    conn.from.classList.add('incorrect-connection');
                    conn.to.classList.add('incorrect-connection');
                }
            });
            if (correctConnectionsCount === totalPossiblePairs && task1State.connections.length === totalPossiblePairs) {
                setFeedback('feedback_task1', `Szuper! Mind a ${totalPossiblePairs} kapcsolat helyes! 🎉`, true);
            } else if (correctConnectionsCount > 0 && task1State.connections.length < totalPossiblePairs) {
                 setFeedback('feedback_task1', `Helyes kapcsolatok: ${correctConnectionsCount}. Még ${totalPossiblePairs - task1State.connections.length} párt kell összekötnöd.`, false);
            } else if (correctConnectionsCount > 0) {
                 setFeedback('feedback_task1', `Helyes kapcsolatok: ${correctConnectionsCount} / ${task1State.connections.length}. Próbáld újra a hibásakat, vagy kösd össze a hiányzókat! (Összesen ${totalPossiblePairs} helyes pár van.)`, false);
            } else {
                 setFeedback('feedback_task1', `Sajnos egyik kapcsolat sem helyes. Próbáld újra! (Összesen ${totalPossiblePairs} helyes pár van.)`, false);
            }
        }

        // --- Feladat 2: Keresd az árnyékát! ---
        let task2State = {};
        function generateTask2(isThemeChange = false) {
            if(!isThemeChange) clearFeedback('feedback_task2');
            const originalShapeDisplay = document.getElementById('shadow_original_shape_display');
            const shadowOptionsArea = document.getElementById('shadow_options_area');
            originalShapeDisplay.innerHTML = '';
            shadowOptionsArea.innerHTML = '';

            const shapeType = ALL_SHAPE_TYPES[Math.floor(Math.random() * ALL_SHAPE_TYPES.length)];
            task2State.correctShapeType = shapeType;
            task2State.selectedShadow = null;

            const originalSvg = createShapeSvg(shapeType, 80);
            originalShapeDisplay.appendChild(originalSvg);

            let options = [shapeType];
            let otherShapes = ALL_SHAPE_TYPES.filter(s => s !== shapeType);
            shuffleArray(otherShapes);
            for(let i=0; i<2; i++) { // 2 hibás opció
                if(otherShapes[i]) options.push(otherShapes[i]);
            }
            shuffleArray(options);
            
            options.forEach((optType, index) => {
                const shadowDiv = document.createElement('div');
                shadowDiv.classList.add('shadow-item', 'shape-item'); // shape-item a méretezéshez és hoverhez
                shadowDiv.dataset.shapeType = optType;
                const shadowSvg = createShapeSvg(optType, 70, { isShadow: true });
                shadowDiv.appendChild(shadowSvg);
                shadowDiv.addEventListener('click', () => handleShadowOptionClick(shadowDiv));
                shadowOptionsArea.appendChild(shadowDiv);
            });
        }
        function handleShadowOptionClick(clickedDiv) {
            // Először minden kiválasztást törlünk
            document.querySelectorAll('#shadow_options_area .shadow-item').forEach(item => {
                item.classList.remove('selected', 'correct-selection', 'incorrect-selection');
            });
            clickedDiv.classList.add('selected');
            task2State.selectedShadow = clickedDiv;
            clearFeedback('feedback_task2');
        }
        function checkTask2() {
            if (!task2State.selectedShadow) {
                setFeedback('feedback_task2', "Kérlek, válassz egy árnyékot!", false);
                return;
            }
            const isCorrect = task2State.selectedShadow.dataset.shapeType === task2State.correctShapeType;
            task2State.selectedShadow.classList.remove('selected');
            task2State.selectedShadow.classList.add(isCorrect ? 'correct-selection' : 'incorrect-selection');
            setFeedback('feedback_task2', isCorrect ? "Helyes! Ez a jó árnyék! 👍" : "Ez nem a helyes árnyék. Próbáld újra!", isCorrect);
        }

        // --- Feladat 3: Hova tartozik? (Csoportosítás) ---
        let task3State = {};
        function generateTask3(isThemeChange = false) {
            if(!isThemeChange) clearFeedback('feedback_task3');
            const draggableArea = document.getElementById('grouping_draggable_shapes_area');
            const bins = [
                document.getElementById('grouping_bin_1'), 
                document.getElementById('grouping_bin_2'),
                document.getElementById('grouping_bin_3')
            ];
            draggableArea.innerHTML = '';
            bins.forEach(bin => {
                 // Töröljük a korábbi gyermek shape-item elemeket, de a szöveget (pl. "KÖRÖK") meghagyjuk
                Array.from(bin.children).forEach(child => {
                    if (child.classList.contains('shape-item')) child.remove();
                });
                bin.classList.remove('correct-bin', 'incorrect-bin');
            });


            const shapesToGroupTypes = ["kor", "negyzet", "haromszog", "kor", "negyzet"]; // 5 alakzat
            shuffleArray(shapesToGroupTypes);
            task3State.shapes = [];
            task3State.binContents = { "grouping_bin_1": [], "grouping_bin_2": [], "grouping_bin_3": [] };

            shapesToGroupTypes.forEach((type, index) => {
                const shapeDiv = document.createElement('div');
                shapeDiv.classList.add('shape-item');
                shapeDiv.id = `group_shape_${index}`;
                shapeDiv.dataset.shapeType = type;
                const svg = createShapeSvg(type, 50);
                shapeDiv.appendChild(svg);
                makeDraggable(shapeDiv, { type: type, id: shapeDiv.id, originalParentId: draggableArea.id });
                draggableArea.appendChild(shapeDiv);
                task3State.shapes.push({id: shapeDiv.id, type: type, currentBin: null});
            });

            bins.forEach(bin => {
                makeDroppable(bin, onDropToBinTask3);
            });
            makeDroppable(draggableArea, onDropToDraggableAreaTask3); // Visszahúzás a kiinduló helyre
        }

        function onDropToBinTask3(draggedItem, binElement, data) {
            const shapeState = task3State.shapes.find(s => s.id === data.id);
            if (shapeState) {
                // Ha már egy másik binben volt, onnan eltávolítjuk
                if(shapeState.currentBin && task3State.binContents[shapeState.currentBin]) {
                    task3State.binContents[shapeState.currentBin] = task3State.binContents[shapeState.currentBin].filter(id => id !== data.id);
                }
                shapeState.currentBin = binElement.id;
                task3State.binContents[binElement.id].push(data.id);
            }
            binElement.appendChild(draggedItem); // Mozgatjuk a DOM-ban is
            draggedItem.style.position = 'relative'; // Biztosítjuk, hogy a normál flow-ban maradjon
            draggedItem.style.left = '';
            draggedItem.style.top = '';
            clearFeedback('feedback_task3');
        }
        function onDropToDraggableAreaTask3(draggedItem, targetArea, data) {
            const shapeState = task3State.shapes.find(s => s.id === data.id);
            if (shapeState && shapeState.currentBin) {
                 task3State.binContents[shapeState.currentBin] = task3State.binContents[shapeState.currentBin].filter(id => id !== data.id);
                 shapeState.currentBin = null;
            }
            targetArea.appendChild(draggedItem);
            clearFeedback('feedback_task3');
        }

        function checkTask3() {
            let allCorrect = true;
            let placedCount = 0;
            document.querySelectorAll('.grouping-bin').forEach(bin => {
                bin.classList.remove('correct-bin', 'incorrect-bin');
                const binType = bin.dataset.shapeType;
                const itemsInBin = Array.from(bin.children).filter(child => child.classList.contains('shape-item'));
                placedCount += itemsInBin.length;

                if (itemsInBin.length > 0) { // Csak akkor ellenőrizzük, ha van benne valami
                    let binIsCorrect = true;
                    itemsInBin.forEach(item => {
                        if (item.dataset.shapeType !== binType) {
                            binIsCorrect = false;
                            allCorrect = false;
                        }
                    });
                    bin.classList.add(binIsCorrect ? 'correct-bin' : 'incorrect-bin');
                     // Stílus hozzáadása a bin-hez (nem az elemekhez közvetlenül itt)
                    if (binIsCorrect) {
                        bin.style.borderColor = getThemeColor('--feedback-correct-border-color', 'green');
                    } else {
                        bin.style.borderColor = getThemeColor('--feedback-incorrect-border-color', 'red');
                    }
                } else {
                     bin.style.borderColor = getThemeColor('--bin-border-default', '#9ca3af'); // Alapértelmezett, ha üres
                }
            });
            const totalShapes = task3State.shapes.length;
            if (placedCount < totalShapes) {
                allCorrect = false; // Nem minden alakzat van a dobozokban
                setFeedback('feedback_task3', `Még nem minden alakzat van a dobozokban! Helyezd el a maradék ${totalShapes - placedCount} alakzatot is.`, false);
                return;
            }

            if (allCorrect) {
                setFeedback('feedback_task3', "Nagyon ügyes! Minden alakzat a helyén van! 🎉", true);
            } else {
                setFeedback('feedback_task3', "Néhány alakzat nincs a jó helyen. Nézd át a piros keretes dobozokat!", false);
            }
        }

        // --- Feladat 4: Melyik nem illik a sorba? (Kakukktojás) ---
        let task4State = {};
        function generateTask4(isThemeChange = false) {
            if(!isThemeChange) clearFeedback('feedback_task4');
            const area = document.getElementById('odd_one_out_area');
            area.innerHTML = '';
            task4State.selectedShape = null;

            const commonShapesCount = 3;
            const commonShapeType = ALL_SHAPE_TYPES[Math.floor(Math.random() * ALL_SHAPE_TYPES.length)];
            let oddShapeType;
            do {
                oddShapeType = ALL_SHAPE_TYPES[Math.floor(Math.random() * ALL_SHAPE_TYPES.length)];
            } while (oddShapeType === commonShapeType);
            
            task4State.oddOneOutType = oddShapeType;
            let shapesToDisplay = [];
            for(let i=0; i<commonShapesCount; i++) shapesToDisplay.push(commonShapeType);
            shapesToDisplay.push(oddShapeType);
            shuffleArray(shapesToDisplay);

            shapesToDisplay.forEach((type, index) => {
                const shapeDiv = document.createElement('div');
                shapeDiv.classList.add('shape-item');
                shapeDiv.dataset.shapeType = type;
                shapeDiv.id = `odd_shape_${index}`;
                const svg = createShapeSvg(type, 60);
                shapeDiv.appendChild(svg);
                shapeDiv.addEventListener('click', () => handleOddOneOutClick(shapeDiv));
                area.appendChild(shapeDiv);
            });
        }
        function handleOddOneOutClick(clickedDiv) {
            document.querySelectorAll('#odd_one_out_area .shape-item').forEach(item => {
                item.classList.remove('selected', 'correct-selection', 'incorrect-selection');
            });
            clickedDiv.classList.add('selected');
            task4State.selectedShape = clickedDiv;
            clearFeedback('feedback_task4');
        }
        function checkTask4() {
            if (!task4State.selectedShape) {
                setFeedback('feedback_task4', "Kérlek, válassz egy alakzatot!", false);
                return;
            }
            const isCorrect = task4State.selectedShape.dataset.shapeType === task4State.oddOneOutType;
             task4State.selectedShape.classList.remove('selected');
            task4State.selectedShape.classList.add(isCorrect ? 'correct-selection' : 'incorrect-selection');
            setFeedback('feedback_task4', isCorrect ? "Helyes! Ez volt a kakukktojás! 🥚" : "Ez az alakzat illik a sorba. Keresd meg azt, amelyik más!", isCorrect);
        }

        // --- Feladat 5: Folytasd a sort! (Alakzatsorozatok) ---
        let task5State = {};
        function generateTask5(isThemeChange = false) {
            if(!isThemeChange) clearFeedback('feedback_task5');
            const sequenceArea = document.getElementById('sequence_display_area');
            const dropTarget = document.getElementById('sequence_drop_target');
            const optionsArea = document.getElementById('sequence_options_area');
            sequenceArea.innerHTML = '';
            dropTarget.innerHTML = '?'; // Reset drop target
            dropTarget.classList.remove('correct-choice', 'incorrect-choice');
            optionsArea.innerHTML = '';
            task5State.droppedShapeType = null;

            // Egyszerű A-B-A-B sorozat
            const typeA = ALL_SHAPE_TYPES[Math.floor(Math.random() * ALL_SHAPE_TYPES.length)];
            let typeB;
            do {
                typeB = ALL_SHAPE_TYPES[Math.floor(Math.random() * ALL_SHAPE_TYPES.length)];
            } while (typeB === typeA);

            const sequence = [typeA, typeB, typeA];
            task5State.correctNext = typeB;

            sequence.forEach(type => {
                const shapeDiv = document.createElement('div');
                shapeDiv.classList.add('shape-item', 'sequence-item-display');
                shapeDiv.appendChild(createShapeSvg(type, 50));
                sequenceArea.appendChild(shapeDiv);
            });
            
            // Opciók
            let options = [task5State.correctNext];
            let wrongOptions = ALL_SHAPE_TYPES.filter(s => s !== task5State.correctNext && s !== typeA);
            shuffleArray(wrongOptions);
            if(wrongOptions[0]) options.push(wrongOptions[0]);
            if(wrongOptions[0] !== typeA && typeA !== task5State.correctNext && options.length < 3) options.push(typeA); // Harmadik opció, ha van értelme
            shuffleArray(options);

            options.slice(0,3).forEach((optType, index) => {
                const optionDiv = document.createElement('div');
                optionDiv.classList.add('shape-item');
                optionDiv.id = `seq_opt_${index}`;
                optionDiv.dataset.shapeType = optType;
                optionDiv.appendChild(createShapeSvg(optType, 50));
                makeDraggable(optionDiv, { type: optType, id: optionDiv.id });
                // Kattintásra is működjön
                optionDiv.addEventListener('click', () => {
                    dropTarget.innerHTML = ''; // Töröljük a "?"-t
                    dropTarget.appendChild(createShapeSvg(optType, 70));
                    task5State.droppedShapeType = optType;
                     document.querySelectorAll('#sequence_options_area .shape-item').forEach(item => item.classList.remove('selected'));
                    optionDiv.classList.add('selected');
                    clearFeedback('feedback_task5');
                });
                optionsArea.appendChild(optionDiv);
            });
             makeDroppable(dropTarget, (draggedItem, target, data) => {
                target.innerHTML = ''; // Clear "?" or previous shape
                target.appendChild(createShapeSvg(data.type, 70)); // Display dragged shape in target
                task5State.droppedShapeType = data.type;
                clearFeedback('feedback_task5');
                 document.querySelectorAll('#sequence_options_area .shape-item').forEach(item => item.classList.remove('selected'));
                 // Find the original option div and mark it as selected
                const originalOption = document.getElementById(data.id);
                if(originalOption) originalOption.classList.add('selected');
            });
        }
        function checkTask5() {
            const dropTarget = document.getElementById('sequence_drop_target');
            dropTarget.classList.remove('correct-choice', 'incorrect-choice');
            if (!task5State.droppedShapeType) {
                setFeedback('feedback_task5', "Kérlek, válassz vagy húzz egy alakzatot a kérdőjel helyére!", false);
                return;
            }
            const isCorrect = task5State.droppedShapeType === task5State.correctNext;
            dropTarget.classList.add(isCorrect ? 'correct-choice' : 'incorrect-choice');
            setFeedback('feedback_task5', isCorrect ? "Ügyes! Ez a helyes folytatás! 🏁" : "Nem ez következik a sorban. Figyelj jobban!", isCorrect);
        }

        // --- Feladat 7: Mi ez az alakzat? ---
        let task7State = {};
        function generateTask7(isThemeChange = false) {
            if(!isThemeChange) clearFeedback('feedback_task7');
            const displayArea = document.getElementById('identify_shape_display_area');
            const optionsContainer = document.getElementById('identify_answer_options');
            displayArea.innerHTML = '';
            optionsContainer.innerHTML = '';
            task7State.selectedOption = null;

            const shapeType = ALL_SHAPE_TYPES[Math.floor(Math.random() * ALL_SHAPE_TYPES.length)];
            task7State.correctType = shapeType;
            displayArea.appendChild(createShapeSvg(shapeType, 90));

            const shapeNames = { kor: "Kör", negyzet: "Négyzet", haromszog: "Háromszög", teglalap: "Téglalap" };
            let options = [shapeType];
            let otherTypes = ALL_SHAPE_TYPES.filter(s => s !== shapeType);
            shuffleArray(otherTypes);
            for(let i=0; i<2; i++) { if(otherTypes[i]) options.push(otherTypes[i]); }
            shuffleArray(options);

            options.forEach(optType => {
                const button = document.createElement('button');
                button.classList.add('answer-option-button');
                button.textContent = shapeNames[optType] || optType;
                button.dataset.shapeType = optType;
                button.addEventListener('click', () => handleIdentifyOptionClick(button));
                optionsContainer.appendChild(button);
            });
        }
        function handleIdentifyOptionClick(clickedButton) {
            document.querySelectorAll('#identify_answer_options .answer-option-button').forEach(btn => {
                btn.classList.remove('selected', 'correct-choice', 'incorrect-choice');
            });
            clickedButton.classList.add('selected');
            task7State.selectedOption = clickedButton;
            clearFeedback('feedback_task7');
        }
        function checkTask7() {
            if (!task7State.selectedOption) {
                setFeedback('feedback_task7', "Kérlek, válassz egy megnevezést!", false);
                return;
            }
            const isCorrect = task7State.selectedOption.dataset.shapeType === task7State.correctType;
            task7State.selectedOption.classList.remove('selected'); // Remove generic selected
            task7State.selectedOption.classList.add(isCorrect ? 'correct-choice' : 'incorrect-choice'); // Add specific feedback class
            setFeedback('feedback_task7', isCorrect ? "Pontosan! Ez egy " + task7State.selectedOption.textContent + ". ✅" : "Ez nem a helyes név. Próbáld újra!", isCorrect);
        }

        // --- Feladat 8: Színezd ki! ---
        let task8State = {};
        const TASK8_COLORS = [
            { name: "piros", value: "#FF0000" }, { name: "kék", value: "#0000FF" },
            { name: "zöld", value: "#008000" }, { name: "sárga", value: "#FFFF00" }
        ];
        function generateTask8(isThemeChange = false) {
            if(!isThemeChange) clearFeedback('feedback_task8');
            const instructionEl = document.getElementById('color_task_instruction');
            const paletteArea = document.getElementById('color_palette_task8');
            const shapesArea = document.getElementById('coloring_shapes_area');
            paletteArea.innerHTML = '';
            shapesArea.innerHTML = '';

            task8State.targetShapeType = ALL_SHAPE_TYPES[Math.floor(Math.random() * ALL_SHAPE_TYPES.length)];
            task8State.targetColor = TASK8_COLORS[Math.floor(Math.random() * TASK8_COLORS.length)];
            task8State.selectedPaletteColor = null;
            task8State.coloredShapes = {}; // id: colorValue

            const shapeNamesPlural = { kor: "köröket", negyzet: "négyzeteket", haromszog: "háromszögeket", teglalap: "téglalapokat" };
            instructionEl.textContent = `Színezd ki az összes ${shapeNamesPlural[task8State.targetShapeType] || task8State.targetShapeType+"-okat/eket"} ${task8State.targetColor.name} színűre!`;
            
            TASK8_COLORS.forEach(color => {
                const btn = document.createElement('button');
                btn.classList.add('color-palette-button');
                btn.style.backgroundColor = color.value;
                btn.dataset.colorValue = color.value;
                btn.dataset.colorName = color.name;
                btn.title = color.name;
                btn.addEventListener('click', () => {
                    task8State.selectedPaletteColor = color;
                    document.querySelectorAll('#color_palette_task8 .color-palette-button').forEach(b => b.classList.remove('selected-color'));
                    btn.classList.add('selected-color');
                });
                paletteArea.appendChild(btn);
            });

            let displayShapes = [task8State.targetShapeType, task8State.targetShapeType]; // Legalább kettő a célból
            let otherShapes = ALL_SHAPE_TYPES.filter(s => s !== task8State.targetShapeType);
            shuffleArray(otherShapes);
            for(let i=0; i<2; i++) { if(otherShapes[i]) displayShapes.push(otherShapes[i]); } // Még 2 másik
            shuffleArray(displayShapes);

            displayShapes.forEach((type, index) => {
                const shapeDiv = document.createElement('div');
                shapeDiv.classList.add('colorable-shape','shape-item');
                shapeDiv.id = `color_shape_${index}`;
                shapeDiv.dataset.shapeType = type;
                // Az SVG fill-je alapértelmezetten a téma színe, vagy egy semleges, ha nincs explicit beállítva
                shapeDiv.appendChild(createShapeSvg(type, 60, { fill: getThemeColor('--shape-fill-default', '#eeeeee') }));
                shapeDiv.addEventListener('click', () => {
                    if (task8State.selectedPaletteColor) {
                        const svgEl = shapeDiv.querySelector('svg > *'); // Get the actual shape element
                        if (svgEl) {
                            svgEl.setAttribute('fill', task8State.selectedPaletteColor.value);
                            task8State.coloredShapes[shapeDiv.id] = task8State.selectedPaletteColor.value;
                            shapeDiv.classList.add('colored-by-user');
                             shapeDiv.classList.remove('correct-color', 'incorrect-color'); // Reset validation style on click
                        }
                    } else {
                        setFeedback('feedback_task8', "Először válassz egy színt a palettáról!", false);
                    }
                });
                shapesArea.appendChild(shapeDiv);
            });
        }
        function checkTask8() {
            let allCorrect = true;
            let mistakesMade = false;
            document.querySelectorAll('#coloring_shapes_area .colorable-shape').forEach(shapeDiv => {
                shapeDiv.classList.remove('correct-color', 'incorrect-color');
                const shapeType = shapeDiv.dataset.shapeType;
                const coloredValue = task8State.coloredShapes[shapeDiv.id];

                if (shapeType === task8State.targetShapeType) { // Ennek a cél színűnek kell lennie
                    if (coloredValue === task8State.targetColor.value) {
                        shapeDiv.classList.add('correct-color');
                    } else {
                        allCorrect = false; mistakesMade = true;
                        shapeDiv.classList.add('incorrect-color'); // Rossz színnel, vagy nincs színezve
                    }
                } else { // Ennek NEM szabad cél színűnek lennie
                    if (coloredValue === task8State.targetColor.value) {
                        allCorrect = false; mistakesMade = true;
                        shapeDiv.classList.add('incorrect-color'); // Ezt nem kellett volna a cél színnel
                    } else if (coloredValue) {
                        // Más színnel színezte, ami nem hiba, csak ha a cél alakzat lett volna
                    }
                }
            });
            if(allCorrect && !mistakesMade) { // Check if any shape was actually colored by the user.
                 let anyTargetShapeColored = false;
                 Object.keys(task8State.coloredShapes).forEach(id => {
                     const div = document.getElementById(id);
                     if(div && div.dataset.shapeType === task8State.targetShapeType && task8State.coloredShapes[id] === task8State.targetColor.value){
                         anyTargetShapeColored = true;
                     }
                 });
                 if (!anyTargetShapeColored && Object.keys(task8State.coloredShapes).length === 0) { // Ha semmit sem színezett
                    setFeedback('feedback_task8', "Még nem színeztél ki semmit. Kezdd el!", false);
                    return;
                 }
            }


            setFeedback('feedback_task8', allCorrect && !mistakesMade ? "Tökéletes színezés! 🎨" : "Valami nem stimmel a színekkel. Nézd át!", !allCorrect || mistakesMade ? false : true);
        }

        // --- Feladat 9: Rajzold meg a hiányzó felét! ---
        let task9Canvas, task9Ctx, task9Drawing = false;
        function generateTask9(isThemeChange = false) {
            if(!isThemeChange) clearFeedback('feedback_task9');
            const canvasContainer = document.getElementById('draw_half_canvas_container_task9');
            if (!document.getElementById('draw_half_canvas_task9')) {
                const newCanvas = document.createElement('canvas');
                newCanvas.id = 'draw_half_canvas_task9';
                canvasContainer.innerHTML = ''; // Clear previous if any
                canvasContainer.appendChild(newCanvas);
            }
            task9Canvas = document.getElementById('draw_half_canvas_task9');
            task9Ctx = task9Canvas.getContext('2d');
            
            // Méretek beállítása a konténerhez
            task9Canvas.width = canvasContainer.clientWidth;
            task9Canvas.height = canvasContainer.clientHeight;

            task9Ctx.clearRect(0, 0, task9Canvas.width, task9Canvas.height);
            task9Ctx.strokeStyle = getThemeColor('--text-color', '#333333');
            task9Ctx.lineWidth = 3;
            task9Ctx.lineJoin = 'round';
            task9Ctx.lineCap = 'round';

            // Előre megrajzolt fél alakzat és tengely
            const W = task9Canvas.width;
            const H = task9Canvas.height;
            task9Ctx.beginPath();
            task9Ctx.moveTo(W/2, H * 0.1); // Szimmetria tengely
            task9Ctx.lineTo(W/2, H * 0.9);
            task9Ctx.setLineDash([5, 3]);
            task9Ctx.stroke();
            task9Ctx.setLineDash([]);

            // Pl. egy fél szív
            task9Ctx.beginPath();
            task9Ctx.moveTo(W/2, H * 0.25);
            task9Ctx.quadraticCurveTo(W*0.1, H*0.1, W*0.1, H*0.4);
            task9Ctx.lineTo(W/2, H*0.7); // Csúcsa a tengelyen
            task9Ctx.stroke();

            task9Canvas.removeEventListener('mousedown', startDrawingTask9);
            task9Canvas.removeEventListener('mousemove', drawTask9);
            task9Canvas.removeEventListener('mouseup', stopDrawingTask9);
            task9Canvas.removeEventListener('mouseout', stopDrawingTask9);

            task9Canvas.addEventListener('mousedown', startDrawingTask9);
            task9Canvas.addEventListener('mousemove', drawTask9);
            task9Canvas.addEventListener('mouseup', stopDrawingTask9);
            task9Canvas.addEventListener('mouseout', stopDrawingTask9);
        }
        function startDrawingTask9(e) {
            task9Drawing = true;
            task9Ctx.beginPath();
            task9Ctx.moveTo(e.offsetX, e.offsetY);
        }
        function drawTask9(e) {
            if (!task9Drawing) return;
            task9Ctx.lineTo(e.offsetX, e.offsetY);
            task9Ctx.stroke();
        }
        function stopDrawingTask9() {
            if (task9Drawing) {
                task9Ctx.closePath();
                task9Drawing = false;
            }
        }
        function clearCanvasTask9() {
            generateTask9(true); // Újragenerálja a vásznat és az alap alakzatot
            clearFeedback('feedback_task9');
        }
        function checkTask9() { // Manuális ellenőrzés
            setFeedback('feedback_task9', "Jól sikerült a rajz? Te vagy a bíró! 😉 Ha nem, radírozz és próbáld újra!", false);
        }
        
        // --- Feladat 10: Építs alakzatokból! ---
        let task10State = {
            requiredShapes: { negyzet: 1, haromszog: 1 }, // Pl. egy házhoz
            paletteShapes: ["negyzet", "haromszog", "kor", "teglalap"],
            placedShapes: [] // {id, type, x, y}
        };
        function generateTask10(isThemeChange = false) {
            if(!isThemeChange) clearFeedback('feedback_task10');
            const paletteArea = document.getElementById('build_palette_task10');
            const canvasArea = document.getElementById('build_canvas_task10');
            paletteArea.innerHTML = '';
            canvasArea.innerHTML = ''; // Clear previously built items
            task10State.placedShapes = [];

            task10State.paletteShapes.forEach((type, index) => {
                const shapeDiv = document.createElement('div');
                shapeDiv.classList.add('shape-item');
                shapeDiv.id = `build_palette_${type}_${index}`;
                shapeDiv.dataset.shapeType = type;
                shapeDiv.appendChild(createShapeSvg(type, 50));
                makeDraggable(shapeDiv, { type: type, id: shapeDiv.id, fromPalette: true });
                paletteArea.appendChild(shapeDiv);
            });

            makeDroppable(canvasArea, onDropToBuildCanvasTask10);
        }

        function onDropToBuildCanvasTask10(draggedItem, targetCanvas, data) {
            const canvasRect = targetCanvas.getBoundingClientRect();
            let newX = event.clientX - canvasRect.left - (draggedItem.offsetWidth / 2);
            let newY = event.clientY - canvasRect.top - (draggedItem.offsetHeight / 2);

            // Korlátozzuk a vásznon belülre
            newX = Math.max(0, Math.min(newX, canvasRect.width - draggedItem.offsetWidth));
            newY = Math.max(0, Math.min(newY, canvasRect.height - draggedItem.offsetHeight));

            if (data.fromPalette) { // Ha a palettáról húzzuk, klónozzuk
                const clone = draggedItem.cloneNode(true); // Mély másolat az SVG-vel együtt
                clone.style.position = 'absolute';
                clone.style.left = newX + 'px';
                clone.style.top = newY + 'px';
                clone.id = `built_shape_${Date.now()}`; // Egyedi ID
                clone.dataset.shapeType = data.type; // Adattípus másolása
                targetCanvas.appendChild(clone);
                task10State.placedShapes.push({id: clone.id, type: data.type, x: newX, y: newY});
                makeDraggable(clone, {type: data.type, id: clone.id, fromPalette: false}); // A vásznon lévő is mozgatható
            } else { // Ha már a vásznon volt, csak mozgatjuk
                draggedItem.style.left = newX + 'px';
                draggedItem.style.top = newY + 'px';
                const shapeState = task10State.placedShapes.find(s => s.id === data.id);
                if(shapeState) {
                    shapeState.x = newX;
                    shapeState.y = newY;
                }
            }
            clearFeedback('feedback_task10');
        }

        function checkTask10() {
            const placedTypesCount = {};
            task10State.placedShapes.forEach(s => {
                placedTypesCount[s.type] = (placedTypesCount[s.type] || 0) + 1;
            });

            let allRequiredMet = true;
            for (const type in task10State.requiredShapes) {
                if ((placedTypesCount[type] || 0) < task10State.requiredShapes[type]) {
                    allRequiredMet = false;
                    break;
                }
            }
            // Egyszerűsített ellenőrzés: csak azt nézzük, megvan-e a szükséges darabszám minden típusból
            // A pontos elrendezés ellenőrzése túl bonyolult lenne 1. osztályban.
            if (allRequiredMet && task10State.placedShapes.length >= Object.values(task10State.requiredShapes).reduce((a,b)=>a+b,0) ) {
                 setFeedback('feedback_task10', "Szép házikó! Megvan minden szükséges elem. 🏠", true);
            } else {
                 let missingMsg = "Hiányoznak még elemek a házikóhoz: ";
                 let missingParts = [];
                 for (const type in task10State.requiredShapes) {
                     const needed = task10State.requiredShapes[type];
                     const placed = placedTypesCount[type] || 0;
                     if (placed < needed) {
                         missingParts.push(`${needed - placed} db ${type}`);
                     }
                 }
                 setFeedback('feedback_task10', missingMsg + missingParts.join(', ') + ".", false);
            }
        }

        document.addEventListener('DOMContentLoaded', function() {
            applyTheme(currentTheme); // Alkalmazza a mentett vagy alapértelmezett témát
            // Az összes feladat generálása induláskor
            const initialGenerators = [
                generateTask1, generateTask2, generateTask3, generateTask4, generateTask5,
                generateTask7, generateTask8, generateTask9, generateTask10
            ];
            initialGenerators.forEach(genFunc => {
                if (typeof genFunc === 'function') {
                    try { genFunc(false); } catch(e) { console.error("Hiba a kezdeti generáláskor: ", genFunc.name, e); }
                }
            });
        });
    </script>
</body>
</html>