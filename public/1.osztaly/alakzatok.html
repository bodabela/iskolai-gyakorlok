<!DOCTYPE html>
<html lang="hu">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>1. Osztály - Alakzatfelismerő</title>
    <style>
        body {
            font-family: 'Arial', sans-serif;
            margin: 0;
            padding: 20px;
            color: #333;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            transition: background-color 0.5s ease, color 0.5s ease;
        }

        .controls-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
            margin-bottom: 20px;
            padding: 10px;
            background-color: rgba(255, 255, 255, 0.9);
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.15);
            width: 100%;
            max-width: 900px;
        }

        .theme-selector {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 8px;
        }

        .control-label {
            font-weight: bold;
            margin-bottom: 5px;
            font-size: 0.95em;
            transition: color 0.5s ease;
        }

        .theme-button {
            padding: 8px 12px;
            border: 1px solid transparent;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            font-size: 0.9em;
            transition: background-color 0.3s ease, color 0.3s ease, border-color 0.3s ease, transform 0.2s ease;
        }
        .theme-button:hover {
            transform: translateY(-1px);
            opacity: 0.9;
        }
        .theme-button.active {
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.2), 0 0 0 2px var(--theme-button-active-border-color, #000);
            transform: translateY(1px);
        }

        .container {
            background-color: #ffffff;
            padding: 20px;
            border-radius: 12px;
            box-shadow: 0 6px 15px rgba(0,0,0,0.15);
            width: 100%;
            max-width: 900px;
            text-align: center;
            transition: background-color 0.5s ease, border-color 0.5s ease;
        }

        h1, h2 {
            text-align: center;
            transition: color 0.5s ease;
        }
        h1 {
            font-size: clamp(1.8em, 5vw, 2.2em);
            margin-bottom: 15px;
        }
        h2 {
            font-size: clamp(1.3em, 4vw, 1.6em);
            margin-bottom: 25px;
        }
        .task {
            margin-bottom: 30px;
            padding: 20px;
            border-radius: 10px;
            transition: background-color 0.5s ease, border-color 0.5s ease;
            border: 1px solid transparent; /* Alap keret, amit a témák felülírhatnak */
        }
        .task-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }
        .task-header h3 {
            margin-top: 0;
            margin-bottom: 0;
            font-size: clamp(1.1em, 3.5vw, 1.3em);
            transition: color 0.5s ease;
        }
        .new-task-button {
            padding: 6px 12px;
            font-size: 0.8em;
            margin-left: 10px;
        }

        .task p.instructions {
            line-height: 1.6;
            font-size: clamp(1em, 3vw, 1.1em);
            margin-bottom: 10px;
            transition: color 0.5s ease;
        }

        button.task-button {
            padding: 10px 20px;
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: clamp(1em, 3vw, 1.1em);
            transition: background-color 0.3s ease, transform 0.2s ease;
            margin-top: 10px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
        }
        button.task-button:hover {
            transform: translateY(-2px);
        }
        button.task-button:active {
            transform: translateY(0px);
        }
        .feedback {
            margin-top: 10px;
            font-weight: bold;
            padding: 8px;
            border-radius: 6px;
            font-size: clamp(0.9em, 2.8vw, 1.05em);
            transition: color 0.5s ease, background-color 0.5s ease, border-color 0.5s ease;
            min-height: 1.5em; /* Hogy ne ugráljon az elrendezés */
        }
        .feedback.correct {
            color: var(--feedback-correct-text-color, #166534); /* green-800 */
            background-color: var(--feedback-correct-bg-color, #dcfce7); /* green-100 */
            border: 1px solid var(--feedback-correct-border-color, #4ade80); /* green-400 */
        }
        .feedback.incorrect {
            color: var(--feedback-incorrect-text-color, #991b1b); /* red-800 */
            background-color: var(--feedback-incorrect-bg-color, #fee2e2); /* red-100 */
            border: 1px solid var(--feedback-incorrect-border-color, #f87171); /* red-400 */
        }

        /* Alakzatfelismerő specifikus stílusok */
        .shape-display-area {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            align-items: center;
            gap: 15px;
            margin-bottom: 20px;
            min-height: 100px;
        }
        .shape-item, .shadow-item, .grouping-bin, .colorable-shape, .sequence-item-display, .position-task-shape {
            width: 70px;
            height: 70px;
            border: 2px solid transparent;
            border-radius: 8px;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: default;
            transition: transform 0.2s ease, border-color 0.3s ease, box-shadow 0.3s ease;
            user-select: none;
            box-sizing: border-box;
        }
         /* A .position-task-shape.target-for-question stílust már nem használjuk a 9. feladatban a kiemelés eltávolítása miatt,
            de meghagyhatjuk itt, hátha más feladatnál kellhet hasonló.
         .position-task-shape.target-for-question {
            border: 3px solid var(--selected-item-border-color, blue) !important;
            transform: scale(1.1);
        } */

        .shape-item:hover, .shadow-item:hover, .colorable-shape:hover, .sequence-item-display:hover {
            transform: scale(1.05);
        }
        .shape-item svg, .shadow-item svg, .colorable-shape svg, .sequence-item-display svg, .position-task-shape svg {
            width: 90%;
            height: 90%;
        }
        .shape-item.selected {
            border-color: var(--selected-item-border-color, #3b82f6) !important;
            box-shadow: 0 0 8px var(--selected-item-border-color, #3b82f6);
        }
        .shape-item.correct-connection, .shadow-item.correct-selection, .colorable-shape.correct-color, .sequence-item-display.correct-choice {
             border-color: var(--feedback-correct-border-color, green) !important;
        }
        .shape-item.incorrect-connection, .shadow-item.incorrect-selection, .colorable-shape.incorrect-color, .sequence-item-display.incorrect-choice  {
            border-color: var(--feedback-incorrect-border-color, red) !important;
        }

        .answer-options-container {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-top: 10px;
            flex-wrap: wrap;
        }
        .answer-option-button {
            padding: 10px 15px;
            font-size: 1em;
            border-radius: 6px;
            cursor: pointer;
            transition: background-color 0.3s, border-color 0.3s, color 0.3s;
            border: 1px solid #ccc;
        }
        .answer-option-button.selected {
            border-color: var(--selected-item-border-color, #3b82f6);
            background-color: var(--selected-item-bg-color, #bfdbfe);
        }


        .connection-line-svg {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 0;
        }
        .connection-line-svg line {
            stroke-width: 3px;
            transition: stroke 0.3s ease;
        }

        .grouping-container {
            display: flex;
            justify-content: space-around;
            align-items: flex-start;
            margin-top: 20px;
            gap: 20px;
            min-height: 150px;
        }
        .grouping-bin { /* Task 3 bin-jei */
            width: 130px; /* Kicsit szélesebb a hosszabb szövegek miatt */
            height: 130px;
            border: 2px dashed;
            border-radius: 10px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            padding: 10px;
            box-sizing: border-box;
            font-weight: bold;
            background-color: var(--grouping-bin-bg, rgba(0,0,0,0.02));
            transition: background-color 0.3s ease;
        }
        .grouping-bin.over {
            background-color: rgba(0,0,0,0.08);
        }

        .color-palette {
            margin-top: 10px;
            margin-bottom: 15px;
            display: flex;
            justify-content: center;
            gap: 10px;
        }
        .color-palette-button {
            width: 30px;
            height: 30px;
            border-radius: 50%;
            border: 2px solid #ccc;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }
        .color-palette-button:hover {
            transform: scale(1.1);
        }
        .color-palette-button.selected-color {
            border-color: var(--selected-item-border-color, black) !important;
            box-shadow: 0 0 5px 2px var(--selected-item-border-color, black);
        }

        /* 9. feladat új stílusai */
        .position-question-text {
            font-size: clamp(1em, 3vw, 1.1em);
            margin-bottom: 8px;
            color: var(--task-instruction-color);
        }
        .position-input-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-top: 5px;
        }
        .position-input-group label {
            font-size: clamp(0.9em, 2.8vw, 1em);
            color: var(--task-instruction-color);
        }
        .position-input-group input[type="number"] {
            width: 50px;
            padding: 8px;
            text-align: center;
            font-size: clamp(0.9em, 2.8vw, 1em);
            border-radius: 5px;
            border: 1px solid var(--task-border, #ccc);
        }
        input.correct-input {
            border-color: var(--feedback-correct-border-color, green) !important;
            box-shadow: 0 0 3px var(--feedback-correct-border-color, green);
        }
        input.incorrect-input {
            border-color: var(--feedback-incorrect-border-color, red) !important;
            box-shadow: 0 0 3px var(--feedback-incorrect-border-color, red);
        }


        /* Téma specifikus CSS változók */
        :root {
            --body-bg-start: #e0f2fe; /* light blue */
            --body-bg-end: #f3e8ff;   /* light purple */
            --container-bg: #ffffff;
            --text-color: #333333;
            --h1-color: #3b82f6; /* blue-500 */
            --h2-color: #6366f1; /* indigo-500 */
            --task-bg: #f9fafb; /* gray-50 */
            --task-border: #e5e7eb; /* gray-200 */
            --task-header-color: #1f2937; /* gray-800 */
            --task-instruction-color: #4b5563; /* gray-600 */
            --button-bg: #3b82f6; /* blue-500 */
            --button-hover-bg: #2563eb; /* blue-600 */
            --theme-button-active-border-color: #60a5fa; /* blue-400 */
            --feedback-correct-text-color: #166534;
            --feedback-correct-bg-color: #dcfce7;
            --feedback-correct-border-color: #4ade80;
            --feedback-incorrect-text-color: #991b1b;
            --feedback-incorrect-bg-color: #fee2e2;
            --feedback-incorrect-border-color: #f87171;
            --selected-item-border-color: #3b82f6; /* blue */
            --selected-item-bg-color: #bfdbfe;  /* light blue for button bg */

            --shape-fill-default: #d1d5db; --shape-stroke-default: #6b7280;
            --shadow-fill-default: #a1a1aa;
            --bin-border-default: #9ca3af; --bin-text-default: #4b5563;
            --grouping-bin-bg: rgba(200,200,200,0.1);
            --connection-line-color: #6b7280;
        }

        body.theme-candy {
            --body-bg-start: #ffebf0; --body-bg-end: #ffe4e1;
            --container-bg: #fff0f5; --text-color: #5c3c4c;
            --h1-color: #ff69b4; --h2-color: #ff1493;
            --task-bg: #fffafa; --task-border: #ffb6c1;
            --task-header-color: #c71585; --task-instruction-color: #db7093;
            --button-bg: #ff69b4; --button-hover-bg: #ff1493;
            --theme-button-active-border-color: #ff85a2;
            --shape-fill-default: #ffc0cb; --shape-stroke-default: #ff69b4;
            --shadow-fill-default: #ffb6c1;
            --bin-border-default: #ffb6c1; --bin-text-default: #c71585;
            --grouping-bin-bg: rgba(255,182,193,0.2);
            --connection-line-color: #ff69b4;
            --selected-item-border-color: #ff1493; --selected-item-bg-color: #ffebf0;
        }
        body.theme-magicforest {
            --body-bg-start: #e6ffe6; --body-bg-end: #d4f0c4;
            --container-bg: #f0fff0; --text-color: #2e452a;
            --h1-color: #556b2f; --h2-color: #228b22;
            --task-bg: #f5fff5; --task-border: #90ee90;
            --task-header-color: #006400; --task-instruction-color: #3cb371;
            --button-bg: #2e8b57; --button-hover-bg: #3cb371;
            --theme-button-active-border-color: #66cdaa;
            --shape-fill-default: #d8bfd8; --shape-stroke-default: #9370db;
            --shadow-fill-default: #b0a0e0;
            --bin-border-default: #dda0dd; --bin-text-default: #8a2be2;
            --grouping-bin-bg: rgba(147,112,219,0.1);
            --connection-line-color: #9370db;
            --selected-item-border-color: #8a2be2; --selected-item-bg-color: #e9d8ff;
        }
        body.theme-ocean {
            --body-bg-start: #e0ffff; --body-bg-end: #afeeee;
            --container-bg: #f0ffff; --text-color: #005050;
            --h1-color: #20b2aa; --h2-color: #008080;
            --task-bg: #f5fffa; --task-border: #7fffd4;
            --task-header-color: #008080; --task-instruction-color: #48d1cc;
            --button-bg: #20b2aa; --button-hover-bg: #40e0d0;
            --theme-button-active-border-color: #5f9ea0;
            --shape-fill-default: #b2ebf2; --shape-stroke-default: #26a69a;
            --shadow-fill-default: #80deea;
            --bin-border-default: #4dd0e1; --bin-text-default: #00897b;
            --grouping-bin-bg: rgba(0,137,123,0.1);
            --connection-line-color: #26a69a;
             --selected-item-border-color: #00897b; --selected-item-bg-color: #b2ebf2;
        }
        body.theme-flowergarden {
            --body-bg-start: #fff8e1; --body-bg-end: #ffecb3;
            --container-bg: #fffaf0; --text-color: #6d4c41;
            --h1-color: #ff7043; --h2-color: #f4511e;
            --task-bg: #fffde7; --task-border: #ffd54f;
            --task-header-color: #e65100; --task-instruction-color: #ff8f00;
            --button-bg: #ff7043; --button-hover-bg: #ff8a65;
            --theme-button-active-border-color: #ffa726;
            --shape-fill-default: #ffe0b2; --shape-stroke-default: #fb8c00;
            --shadow-fill-default: #ffcc80;
            --bin-border-default: #ffb74d; --bin-text-default: #e65100;
            --grouping-bin-bg: rgba(230,81,0,0.1);
            --connection-line-color: #fb8c00;
            --selected-item-border-color: #e65100; --selected-item-bg-color: #ffe0b2;
        }
        body.theme-sky {
            --body-bg-start: #e1f5fe; --body-bg-end: #b3e5fc;
            --container-bg: #f0f9ff; --text-color: #01579b;
            --h1-color: #03a9f4; --h2-color: #0288d1;
            --task-bg: #e3f2fd; --task-border: #81d4fa;
            --task-header-color: #01579b; --task-instruction-color: #039be5;
            --button-bg: #03a9f4; --button-hover-bg: #29b6f6;
            --theme-button-active-border-color: #4fc3f7;
            --shape-fill-default: #b3e5fc; --shape-stroke-default: #03a9f4;
            --shadow-fill-default: #81d4fa;
            --bin-border-default: #4fc3f7; --bin-text-default: #0288d1;
            --grouping-bin-bg: rgba(2,136,209,0.1);
            --connection-line-color: #03a9f4;
            --selected-item-border-color: #0288d1; --selected-item-bg-color: #b3e5fc;
        }
        body.theme-space {
            --body-bg-start: #2c3e50; --body-bg-end: #34495e;
            --container-bg: #1f2c38; --text-color: #ecf0f1;
            --h1-color: #3498db; --h2-color: #2980b9;
            --task-bg: #2c3a47; --task-border: #5d6d7e;
            --task-header-color: #bdc3c7; --task-instruction-color: #95a5a6;
            --button-bg: #3498db; --button-hover-bg: #5dade2;
            --theme-button-active-border-color: #85c1e9;
            --shape-fill-default: #4b5563; --shape-stroke-default: #9ca3af;
             --shadow-fill-default: #6b7280;
             --bin-border-default: #374151; --bin-text-default: #9ca3af;
             --grouping-bin-bg: rgba(55,65,81,0.2);
             --connection-line-color: #9ca3af;
             --selected-item-border-color: #3498db; --selected-item-bg-color: #4b5563;
        }
        body.theme-jungle {
            --body-bg-start: #38761d; --body-bg-end: #6aa84f;
            --container-bg: #2a531b; --text-color: #e8f5e9;
            --h1-color: #93c47d; --h2-color: #b6d7a8;
            --task-bg: #3a632cc7; --task-border: #799e6c;
            --task-header-color: #d9ead3; --task-instruction-color: #c9dfc0;
            --button-bg: #6aa84f; --button-hover-bg: #8fbc8f;
            --theme-button-active-border-color: #a9d18e;
            --shape-fill-default: #a7f3d0; --shape-stroke-default: #059669;
            --shadow-fill-default: #6ee7b7;
            --bin-border-default: #34d399; --bin-text-default: #047857;
            --grouping-bin-bg: rgba(4,120,87,0.1);
            --connection-line-color: #059669;
            --selected-item-border-color: #047857; --selected-item-bg-color: #a7f3d0;
        }
        body.theme-tech {
            --body-bg-start: #37474f; --body-bg-end: #546e7a;
            --container-bg: #263238; --text-color: #cfd8dc;
            --h1-color: #00bcd4; --h2-color: #00acc1;
            --task-bg: #303f46; --task-border: #546e7a;
            --task-header-color: #b0bec5; --task-instruction-color: #90a4ae;
            --button-bg: #00bcd4; --button-hover-bg: #26c6da;
            --theme-button-active-border-color: #4dd0e1;
            --shape-fill-default: #546e7a; --shape-stroke-default: #00acc1;
            --shadow-fill-default: #78909c;
            --bin-border-default: #455a64; --bin-text-default: #26c6da;
            --grouping-bin-bg: rgba(38,198,218,0.1);
            --connection-line-color: #00acc1;
            --selected-item-border-color: #26c6da; --selected-item-bg-color: #546e7a;
        }
         body.theme-sport {
            --body-bg-start: #e3f2fd; --body-bg-end: #bbdefb;
            --container-bg: #f1f8e9; --text-color: #212121;
            --h1-color: #ff5722; --h2-color: #f44336;
            --task-bg: #fff; --task-border: #90caf9;
            --task-header-color: #0d47a1; --task-instruction-color: #1976d2;
            --button-bg: #4caf50; --button-hover-bg: #66bb6a;
            --theme-button-active-border-color: #81c784;
            --shape-fill-default: #90caf9; --shape-stroke-default: #1e88e5;
            --shadow-fill-default: #64b5f6;
            --bin-border-default: #42a5f5; --bin-text-default: #1976d2;
            --grouping-bin-bg: rgba(25,118,210,0.1);
            --connection-line-color: #1e88e5;
            --selected-item-border-color: #1976d2; --selected-item-bg-color: #90caf9;
        }
        body.theme-adventure {
            --body-bg-start: #efebe9; --body-bg-end: #d7ccc8;
            --container-bg: #f5f5f5; --text-color: #3e2723;
            --h1-color: #8d6e63; --h2-color: #795548;
            --task-bg: #fafafa; --task-border: #a1887f;
            --task-header-color: #4e342e; --task-instruction-color: #6d4c41;
            --button-bg: #795548; --button-hover-bg: #8d6e63;
            --theme-button-active-border-color: #a1887f;
            --shape-fill-default: #bcaaa4; --shape-stroke-default: #795548;
            --shadow-fill-default: #a1887f;
            --bin-border-default: #8d6e63; --bin-text-default: #5d4037;
            --grouping-bin-bg: rgba(93,64,55,0.1);
            --connection-line-color: #795548;
            --selected-item-border-color: #5d4037; --selected-item-bg-color: #bcaaa4;
        }

        .theme-button { background-color: var(--task-bg); color: var(--task-header-color); border: 1px solid var(--task-border); }
        .theme-button:hover { opacity: 1; background-color: var(--task-border); }
        .theme-button.active { background-color: var(--button-bg); color: white; border-color: var(--button-bg); box-shadow: inset 0 1px 3px rgba(0,0,0,0.2), 0 0 0 2px var(--theme-button-active-border-color); }
        button.task-button, button.new-task-button { background-color: var(--button-bg); color: white; }
        button.task-button:hover, button.new-task-button:hover { background-color: var(--button-hover-bg); }
        input[type="text"], input[type="number"] { border: 1px solid var(--task-border); background-color: var(--container-bg); color: var(--text-color); padding: 8px; border-radius: 4px; }
        input[type="text"]:focus, input[type="number"]:focus { border-color: var(--button-bg); box-shadow: 0 0 0 2px var(--theme-button-active-border-color); outline: none; }
        .answer-option-button { background-color: var(--task-bg); color: var(--task-instruction-color); border: 1px solid var(--task-border); }
        .answer-option-button:hover { border-color: var(--button-hover-bg); background-color: var(--task-border); }
        .answer-option-button.selected { background-color: var(--selected-item-bg-color); color: var(--button-bg); border-color: var(--selected-item-border-color); font-weight: bold; }

    </style>
</head>
<body>
    <div class="controls-container">
        <div>
            <p class="control-label">Téma választó:</p>
            <div class="theme-selector">
                <button class="theme-button" data-theme="theme-candy">Cukorka</button>
                <button class="theme-button" data-theme="theme-magicforest">Varázserdő</button>
                <button class="theme-button" data-theme="theme-ocean">Óceán</button>
                <button class="theme-button" data-theme="theme-flowergarden">Virágoskert</button>
                <button class="theme-button" data-theme="theme-sky">Égbolt</button>
                <button class="theme-button" data-theme="theme-space">Űr</button>
                <button class="theme-button" data-theme="theme-jungle">Őserdő</button>
                <button class="theme-button" data-theme="theme-tech">Techno</button>
                <button class="theme-button" data-theme="theme-sport">Sport</button>
                <button class="theme-button" data-theme="theme-adventure">Kaland</button>
                 <button class="theme-button" data-theme="default">Alapértelmezett</button>
            </div>
        </div>
    </div>

    <div class="container">
        <h1>Alakzatfelismerő Feladatok</h1>
        <h2>1. Osztály</h2>

        <div class="task" id="task1_connect_shapes">
            <div class="task-header">
                <h3 style="color: var(--task-header-color);">1. Feladat: Kösd össze az egyformákat!</h3>
                <button class="task-button new-task-button" onclick="generateTask1()">Új feladat</button>
            </div>
            <p class="instructions" style="color: var(--task-instruction-color);">Húzd a vonalat az összetartozó alakzatok között! (Kattints az elsőre, majd a másodikra.)</p>
            <div class="shape-display-area" id="connect_shapes_area" style="position: relative;">
                <svg class="connection-line-svg" id="connection_lines_svg_task1"></svg>
                <div id="connect_col1" style="display: flex; flex-direction: column; gap: 15px; z-index: 1;"></div>
                <div id="connect_col2" style="display: flex; flex-direction: column; gap: 15px; z-index: 1;"></div>
            </div>
            <button class="task-button" onclick="checkTask1()">Ellenőrzés</button>
            <p id="feedback_task1" class="feedback"></p>
        </div>

        <div class="task" id="task2_find_shadow">
            <div class="task-header">
                <h3 style="color: var(--task-header-color);">2. Feladat: Keresd az árnyékát!</h3>
                <button class="task-button new-task-button" onclick="generateTask2()">Új feladat</button>
            </div>
            <p class="instructions" style="color: var(--task-instruction-color);">Melyik árnyék tartozik a színes alakzathoz? Kattints a helyes árnyékra!</p>
            <div style="display: flex; justify-content: center; align-items: center; gap: 30px; margin-bottom: 20px;">
                <div class="shape-item" id="shadow_original_shape_display"></div>
            </div>
            <div class="shape-display-area" id="shadow_options_area"></div>
            <button class="task-button" onclick="checkTask2()">Ellenőrzés</button>
            <p id="feedback_task2" class="feedback"></p>
        </div>

        <div class="task" id="task3_group_shapes">
            <div class="task-header">
                <h3 style="color: var(--task-header-color);">3. Feladat: Hova tartozik?</h3>
                <button class="task-button new-task-button" onclick="generateTask3()">Új feladat</button>
            </div>
            <p class="instructions" style="color: var(--task-instruction-color);">Húzd az alakzatokat a megfelelő dobozba!</p>
            <div class="shape-display-area" id="grouping_draggable_shapes_area" style="margin-bottom: 30px; min-height:90px;">
                </div>
            <div class="grouping-container">
                <div class="grouping-bin" id="grouping_bin_korok" data-category="kor" style="border-color: var(--bin-border-default); color: var(--bin-text-default);">KÖRÖK</div>
                <div class="grouping-bin" id="grouping_bin_negyszogek" data-category="negyszog" style="border-color: var(--bin-border-default); color: var(--bin-text-default);">NÉGYSZÖGEK</div>
                <div class="grouping-bin" id="grouping_bin_haromszogek" data-category="haromszog" style="border-color: var(--bin-border-default); color: var(--bin-text-default);">HÁROMSZÖGEK</div>
            </div>
            <button class="task-button" onclick="checkTask3()">Ellenőrzés</button>
            <p id="feedback_task3" class="feedback"></p>
        </div>

        <div class="task" id="task4_odd_one_out">
            <div class="task-header">
                <h3 style="color: var(--task-header-color);">4. Feladat: Melyik nem illik a sorba?</h3>
                <button class="task-button new-task-button" onclick="generateTask4()">Új feladat</button>
            </div>
            <p class="instructions" style="color: var(--task-instruction-color);">Kattints arra az alakzatra, amelyik nem illik a többi közé!</p>
            <div class="shape-display-area" id="odd_one_out_area"></div>
            <button class="task-button" onclick="checkTask4()">Ellenőrzés</button>
            <p id="feedback_task4" class="feedback"></p>
        </div>

        <div class="task" id="task5_continue_sequence">
            <div class="task-header">
                <h3 style="color: var(--task-header-color);">5. Feladat: Folytasd a sort!</h3>
                <button class="task-button new-task-button" onclick="generateTask5()">Új feladat</button>
            </div>
            <p class="instructions" style="color: var(--task-instruction-color);">Figyeld meg a sorozatot! Melyik alakzat következik? Húzd a helyére, vagy kattints rá!</p>
            <div style="display: flex; flex-direction: column; align-items: center; gap: 20px;">
                <div class="shape-display-area" id="sequence_display_area" style="border-bottom: 2px solid var(--task-border); padding-bottom: 10px;">
                    </div>
                <div class="shape-item" id="sequence_drop_target" style="border: 2px dashed var(--task-border); width: 85px; height: 85px; font-size: 2em; color: var(--task-instruction-color);">?</div>
                <div class="shape-display-area" id="sequence_options_area" style="margin-top: 15px;">
                    </div>
            </div>
            <button class="task-button" onclick="checkTask5()">Ellenőrzés</button>
            <p id="feedback_task5" class="feedback"></p>
        </div>

        <div class="task" id="task7_identify_shape">
            <div class="task-header">
                <h3 style="color: var(--task-header-color);">7. Feladat: Mi ez az alakzat?</h3>
                <button class="task-button new-task-button" onclick="generateTask7()">Új feladat</button>
            </div>
            <p class="instructions" style="color: var(--task-instruction-color);">Kattints az alakzat helyes megnevezésére!</p>
            <div class="shape-display-area" id="identify_shape_display_area">
                </div>
            <div class="answer-options-container" id="identify_answer_options">
                </div>
            <button class="task-button" onclick="checkTask7()">Ellenőrzés</button>
            <p id="feedback_task7" class="feedback"></p>
        </div>

        <div class="task" id="task8_color_shapes">
            <div class="task-header">
                <h3 style="color: var(--task-header-color);">8. Feladat: Színezd ki!</h3>
                <button class="task-button new-task-button" onclick="generateTask8()">Új feladat</button>
            </div>
            <p class="instructions" id="color_task_instruction" style="color: var(--task-instruction-color);">Válaszd ki a színt, majd kattints azokra az alakzatokra, amiket ki szeretnél színezni!</p>
            <div class="color-palette" id="color_palette_task8"></div>
            <div class="shape-display-area" id="coloring_shapes_area"></div>
            <button class="task-button" onclick="checkTask8()">Ellenőrzés</button>
            <p id="feedback_task8" class="feedback"></p>
        </div>

        <div class="task" id="task9_shape_position">
            <div class="task-header">
                <h3 style="color: var(--task-header-color);">9. Feladat: Hol helyezkedik el?</h3>
                <button class="task-button new-task-button" onclick="generateTask9()">Új feladat</button>
            </div>
            <p class="instructions" id="position_task_instruction_text" style="color: var(--task-instruction-color);">Figyeld meg az alakzatokat! A sorban lévő alakzat balról és jobbról hanyadik?</p>
            <div class="shape-display-area" id="position_shapes_display_area">
                </div>
            <div class="position-input-group">
                <label for="position_input_left">Balról a(z):</label>
                <input type="number" id="position_input_left" min="1">
                <label for="position_input_right" style="margin-left: 15px;">Jobbról a(z):</label>
                <input type="number" id="position_input_right" min="1">
            </div>
            <button class="task-button" onclick="checkTask9()">Ellenőrzés</button>
            <p id="feedback_task9" class="feedback"></p>
        </div>


        <div class="task" id="task10_build_with_shapes">
            <div class="task-header">
                <h3 style="color: var(--task-header-color);">10. Feladat: Építkezzünk!</h3>
                <button class="task-button new-task-button" onclick="generateTask10()">Új feladat</button>
            </div>
            <p class="instructions" id="build_task_instruction" style="color: var(--task-instruction-color);">Húzd az alakzatokat a helyükre, hogy megépítsd a kért dolgot!</p>
            <div class="build-area-container">
                <div class="build-palette" id="build_palette_task10">
                    </div>
                <div class="build-canvas" id="build_canvas_task10">
                    </div>
            </div>
            <button class="task-button" onclick="checkTask10()">Ellenőrzés</button>
            <p id="feedback_task10" class="feedback"></p>
        </div>

    </div>

    <script>
        // --- GLOBÁLIS KONSTANSOK ÉS SEGÉDFÜGGVÉNYEK ---
        const SVG_NS = "http://www.w3.org/2000/svg";
        const ALL_SHAPE_TYPES = [
            "kor", "negyzet", "haromszog", "teglalap",
            "otszog", "hatszog", "trapez", "rombusz", "paralelogramma"
        ];
        const SHAPE_CATEGORIES = {
            "kor": "kor",
            "negyzet": "negyszog",
            "teglalap": "negyszog",
            "rombusz": "negyszog",
            "paralelogramma": "negyszog",
            "trapez": "negyszog",
            "haromszog": "haromszog",
            "otszog": "otszog", // Ezeknek nincs külön kategóriájuk a 3. feladatban
            "hatszog": "hatszog"  // Ezeknek sincs
        };

        const SHAPE_NAMES = {
            kor: "kör", negyzet: "négyzet", haromszog: "háromszög", teglalap: "téglalap",
            otszog: "ötszög", hatszog: "hatszög", trapez: "trapéz", rombusz: "rombusz",
            paralelogramma: "paralelogramma"
        };
        const SHAPE_NAMES_PLURAL = {
            kor: "köröket", negyzet: "négyzeteket", haromszog: "háromszögeket", teglalap: "téglalapokat",
            otszog: "ötszögeket", hatszog: "hatszögeket", trapez: "trapézokat", rombusz: "rombuszokat",
            paralelogramma: "paralelogrammákat"
        };


        const TASK8_COLORS = [
            { name: "piros", value: "#FF0000" }, { name: "kék", value: "#0000FF" },
            { name: "zöld", value: "#008000" }, { name: "sárga", value: "#FFFF00" }
        ];

        function getRandomInt(min, max) {
            min = Math.ceil(min);
            max = Math.floor(max);
            return Math.floor(Math.random() * (max - min + 1)) + min;
        }

        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
            return array;
        }

        function getThemeColor(variableName, fallbackColor) {
            if (document.body) {
                const color = getComputedStyle(document.body).getPropertyValue(variableName).trim();
                return color || fallbackColor;
            }
            return fallbackColor;
        }

        function createShapeSvg(type, size = 60, options = {}) {
            const svg = document.createElementNS(SVG_NS, "svg");
            svg.setAttribute("viewBox", `0 0 ${size} ${size}`);
            svg.setAttribute("width", size);
            svg.setAttribute("height", size);

            const strokeWidth = options.strokeWidth || Math.max(1, size * 0.035);
            const padding = strokeWidth / 2; 

            const defaultFill = getThemeColor('--shape-fill-default', '#d1d5db');
            const defaultStroke = getThemeColor('--shape-stroke-default', '#6b7280');
            const shadowFill = getThemeColor('--shadow-fill-default', '#a1a1aa');

            const currentFill = options.isShadow ? shadowFill : (options.fill || defaultFill);
            const currentStroke = options.isShadow ? "none" : (options.stroke || defaultStroke);

            let shapeEl;
            switch (type) {
                case "kor":
                    shapeEl = document.createElementNS(SVG_NS, "circle");
                    shapeEl.setAttribute("cx", size / 2);
                    shapeEl.setAttribute("cy", size / 2);
                    shapeEl.setAttribute("r", Math.max(1, size / 2 - padding));
                    break;
                case "negyzet":
                    shapeEl = document.createElementNS(SVG_NS, "rect");
                    shapeEl.setAttribute("x", padding);
                    shapeEl.setAttribute("y", padding);
                    shapeEl.setAttribute("width", Math.max(1, size - 2 * padding));
                    shapeEl.setAttribute("height", Math.max(1, size - 2 * padding));
                    shapeEl.setAttribute("rx", size * 0.05);
                    break;
                case "haromszog": 
                    shapeEl = document.createElementNS(SVG_NS, "polygon");
                    const sideH_eq = size - 2 * padding;
                    const triangleHeight_eq = (Math.sqrt(3) / 2) * sideH_eq;
                    const topYH_eq = (size - triangleHeight_eq) / 2 ;
                    const bottomYH_eq = topYH_eq + triangleHeight_eq;
                    shapeEl.setAttribute("points", `${size/2},${topYH_eq} ${padding},${bottomYH_eq} ${size-padding},${bottomYH_eq}`);
                    break;
                case "teglalap":
                    shapeEl = document.createElementNS(SVG_NS, "rect");
                    shapeEl.setAttribute("x", padding);
                    shapeEl.setAttribute("y", size * 0.25 + padding / 2); 
                    shapeEl.setAttribute("width", Math.max(1, size - 2 * padding));
                    shapeEl.setAttribute("height", Math.max(1, size * 0.5 - padding));
                    shapeEl.setAttribute("rx", size * 0.05);
                    break;
                case "otszog": 
                    shapeEl = document.createElementNS(SVG_NS, "polygon");
                    let pointsO = "";
                    const radiusO = size / 2 - padding;
                    const centerXO = size / 2;
                    const centerYO = size / 2;
                    for (let i = 0; i < 5; i++) {
                        pointsO += `${centerXO + radiusO * Math.cos(Math.PI / 2 - (2 * Math.PI * i) / 5)},${centerYO - radiusO * Math.sin(Math.PI / 2 - (2 * Math.PI * i) / 5)} `;
                    }
                    shapeEl.setAttribute("points", pointsO.trim());
                    break;
                case "hatszog": 
                    shapeEl = document.createElementNS(SVG_NS, "polygon");
                    let pointsHex = "";
                    const radiusHex = size / 2 - padding;
                    const centerXHex = size/2;
                    const centerYHex = size/2;
                    for (let i = 0; i < 6; i++) {
                        pointsHex += `${centerXHex + radiusHex * Math.cos((Math.PI/6) + (2 * Math.PI * i) / 6)},${centerYHex + radiusHex * Math.sin((Math.PI/6) + (2 * Math.PI * i) / 6)} `;
                    }
                    shapeEl.setAttribute("points", pointsHex.trim());
                    break;
                case "trapez": 
                    shapeEl = document.createElementNS(SVG_NS, "polygon");
                    const topWidthT = (size - 2 * padding) * 0.5; // Kisebb felső alap
                    const bottomWidthT = size - 2 * padding;
                    const heightT = (size - 2 * padding) * 0.6;
                    const topY_T = (size - heightT) / 2;
                    const bottomY_T = topY_T + heightT;
                    const topX1_T = (size - topWidthT) / 2;
                    const topX2_T = topX1_T + topWidthT;
                    const bottomX1_T = padding;
                    const bottomX2_T = size-padding;
                    shapeEl.setAttribute("points", `${topX1_T},${topY_T} ${topX2_T},${topY_T} ${bottomX2_T},${bottomY_T} ${bottomX1_T},${bottomY_T}`);
                    break;
                case "rombusz":
                    shapeEl = document.createElementNS(SVG_NS, "polygon");
                    const midX_R = size / 2;
                    const midY_R = size / 2;
                    const diagX_R = size - 2 * padding; // Vízszintes átló
                    const diagY_R = (size - 2 * padding) * 0.7; // Függőleges átló (kisebb)
                    shapeEl.setAttribute("points", `${midX_R},${midY_R - diagY_R/2} ${midX_R + diagX_R/2},${midY_R} ${midX_R},${midY_R + diagY_R/2} ${midX_R - diagX_R/2},${midY_R}`);
                    break;
                case "paralelogramma":
                    shapeEl = document.createElementNS(SVG_NS, "polygon");
                    const width_P = (size - 2 * padding) * 0.8;
                    const height_P = (size - 2 * padding) * 0.5;
                    const skew_P = (size - 2 * padding) * 0.3; // Dőlés mértéke
                    const y_P_top = (size - height_P) / 2;
                    const y_P_bottom = y_P_top + height_P;
                    const x_P_top_left = padding + skew_P;
                    const x_P_top_right = padding + skew_P + width_P;
                    const x_P_bottom_left = padding;
                    const x_P_bottom_right = padding + width_P;
                    shapeEl.setAttribute("points", `${x_P_top_left},${y_P_top} ${x_P_top_right},${y_P_top} ${x_P_bottom_right},${y_P_bottom} ${x_P_bottom_left},${y_P_bottom}`);
                    break;
                 default: 
                    shapeEl = document.createElementNS(SVG_NS, "text");
                    shapeEl.setAttribute("x", size/2);
                    shapeEl.setAttribute("y", size/2);
                    shapeEl.setAttribute("text-anchor", "middle");
                    shapeEl.setAttribute("dominant-baseline", "central");
                    shapeEl.setAttribute("font-size", size * 0.8);
                    shapeEl.setAttribute("fill", getThemeColor('--text-color', '#333'));
                    shapeEl.textContent = "?";
            }
            if (shapeEl) {
                if (type !== "default") { 
                    shapeEl.setAttribute("fill", currentFill);
                    shapeEl.setAttribute("stroke", currentStroke);
                    shapeEl.setAttribute("stroke-width", strokeWidth);
                }
                if (options.transform) shapeEl.setAttribute("transform", options.transform);
                svg.appendChild(shapeEl);
            }
            return svg;
        }


        function clearFeedback(feedbackElId) {
            const el = document.getElementById(feedbackElId);
            if (el) {
                el.innerHTML = '';
                el.className = 'feedback';
            }
        }

        function setFeedback(feedbackElId, message, isCorrect) {
            const el = document.getElementById(feedbackElId);
            if (el) {
                el.innerHTML = message;
                el.className = `feedback ${isCorrect ? 'correct' : 'incorrect'}`;
                 if (isCorrect) {
                    setTimeout(() => {
                         if(el.classList.contains('correct')) {
                             el.innerHTML = '';
                             el.className = 'feedback';
                         }
                    }, 3000);
                }
            }
        }

        let draggedElement = null;
        let draggedElementData = null;

        function makeDraggable(element, data) {
            element.draggable = true;
            element.style.cursor = 'grab';
            element.addEventListener('dragstart', (event) => {
                draggedElement = element;
                draggedElementData = data || { type: element.dataset.shapeType, id: element.id, originalParentId: element.parentElement.id };
                event.dataTransfer.setData('text/plain', JSON.stringify(draggedElementData));
                event.dataTransfer.effectAllowed = 'move';
                element.style.opacity = '0.5';
                element.classList.add('dragging');
            });
            element.addEventListener('dragend', (event) => {
                element.style.opacity = '1';
                element.style.cursor = 'grab';
                element.classList.remove('dragging');
            });
        }

        function makeDroppable(element, onDropCallback) {
            element.addEventListener('dragover', (event) => {
                event.preventDefault();
                event.dataTransfer.dropEffect = 'move';
                element.classList.add('over');
            });
            element.addEventListener('dragleave', () => {
                element.classList.remove('over');
            });
            element.addEventListener('drop', (event) => {
                event.preventDefault();
                element.classList.remove('over');
                const data = JSON.parse(event.dataTransfer.getData('text/plain'));
                if (draggedElement && data) {
                    onDropCallback(draggedElement, element, data);
                }
                draggedElement = null;
                draggedElementData = null;
            });
        }
        // --- END SEGÉDFÜGGVÉNYEK ---


        // --- TÉMA KEZELÉS ---
        const bodyEl = document.body;
        const themeButtons = document.querySelectorAll('.theme-button');
        let currentTheme = localStorage.getItem('alakzatokPageTheme') || 'theme-candy';

        function applyTheme(themeClass) {
            if (!document.body) {
                console.warn("applyTheme hívva, mielőtt a body betöltődött volna.");
                return;
            }
            document.body.className = '';
            if (themeClass !== 'default') {
                 document.body.classList.add(themeClass);
            }
            currentTheme = themeClass;
            localStorage.setItem('alakzatokPageTheme', themeClass);

            themeButtons.forEach(btn => {
                btn.classList.toggle('active', btn.dataset.theme === themeClass);
            });

            const styles = getComputedStyle(document.body);
            document.documentElement.style.setProperty('--current-body-bg-start', styles.getPropertyValue('--body-bg-start').trim());
            document.documentElement.style.setProperty('--current-body-bg-end', styles.getPropertyValue('--body-bg-end').trim());
            document.body.style.background = `linear-gradient(to bottom right, var(--current-body-bg-start), var(--current-body-bg-end))`;

            const containerEl = document.querySelector('.container');
            if(containerEl) containerEl.style.backgroundColor = styles.getPropertyValue('--container-bg').trim();
            document.body.style.color = styles.getPropertyValue('--text-color').trim();

            const h1El = document.querySelector('h1');
            if (h1El) h1El.style.color = styles.getPropertyValue('--h1-color').trim();
            const h2El = document.querySelector('h2');
            if (h2El) h2El.style.color = styles.getPropertyValue('--h2-color').trim();

            document.querySelectorAll('.task').forEach(task => {
                task.style.backgroundColor = styles.getPropertyValue('--task-bg').trim();
                task.style.borderColor = styles.getPropertyValue('--task-border').trim();
            });

            const isThemeChange = true;
            if (typeof generateTask1 === 'function') try { generateTask1(isThemeChange); } catch(e){console.warn("Hiba T1 újragenerálásakor témaváltáskor:",e)}
            if (typeof generateTask2 === 'function') try { generateTask2(isThemeChange); } catch(e){console.warn("Hiba T2 újragenerálásakor témaváltáskor:",e)}
            if (typeof generateTask3 === 'function') try { generateTask3(isThemeChange); } catch(e){console.warn("Hiba T3 újragenerálásakor témaváltáskor:",e)}
            if (typeof generateTask4 === 'function') try { generateTask4(isThemeChange); } catch(e){console.warn("Hiba T4 újragenerálásakor témaváltáskor:",e)}
            if (typeof generateTask5 === 'function') try { generateTask5(isThemeChange); } catch(e){console.warn("Hiba T5 újragenerálásakor témaváltáskor:",e)}
            if (typeof generateTask7 === 'function') try { generateTask7(isThemeChange); } catch(e){console.warn("Hiba T7 újragenerálásakor témaváltáskor:",e)}
            if (typeof generateTask8 === 'function') try { generateTask8(isThemeChange); } catch(e){console.warn("Hiba T8 újragenerálásakor témaváltáskor:",e)}
            if (typeof generateTask9 === 'function') try { generateTask9(isThemeChange); } catch(e){console.warn("Hiba T9 újragenerálásakor témaváltáskor:",e.message, e.stack)}
            if (typeof generateTask10 === 'function') try { generateTask10(isThemeChange); } catch(e){console.warn("Hiba T10 újragenerálásakor témaváltáskor:",e)}
        }

        themeButtons.forEach(button => {
            button.addEventListener('click', () => {
                applyTheme(button.dataset.theme);
            });
        });
        // --- END TÉMA KEZELÉS ---


        // --- FELADAT SPECIFIKUS LOGIKA ---
        let task1State = {};
        function generateTask1(isThemeChange = false) {
            if (!isThemeChange) clearFeedback('feedback_task1');
            const col1Container = document.getElementById('connect_col1');
            const col2Container = document.getElementById('connect_col2');
            const svgLinesContainer = document.getElementById('connection_lines_svg_task1');
            col1Container.innerHTML = '';
            col2Container.innerHTML = '';
            svgLinesContainer.innerHTML = '';

            const availableForTask1 = ["kor", "negyzet", "haromszog", "teglalap", "otszog", "rombusz"];
            let baseShapes = [];
            const numberOfPairs = 3; // Marad 3 pár
            let usedTypes = []; // Hogy biztosítsuk a változatosságot, ha lehet

            for(let i=0; i < numberOfPairs; i++){
                let randomType;
                // Próbáljunk meg nem ismétlődő alakzatokat választani, ha van elég
                if (usedTypes.length < availableForTask1.length) {
                    do {
                        randomType = availableForTask1[Math.floor(Math.random() * availableForTask1.length)];
                    } while (usedTypes.includes(randomType));
                    usedTypes.push(randomType);
                } else { // Ha már minden típust használtunk, akkor jöhet ismétlődés
                    randomType = availableForTask1[Math.floor(Math.random() * availableForTask1.length)];
                }
                baseShapes.push(randomType);
            }


            let column1ShapesData = [...baseShapes];
            let column2ShapesData = [...baseShapes];
            shuffleArray(column1ShapesData);
            shuffleArray(column2ShapesData);

            task1State = {
                col1: [],
                col2: [],
                connections: [],
                selectedShape: null,
                mapCol1: column1ShapesData,
                mapCol2: column2ShapesData
            };
            const shapeSize = 65;
            column1ShapesData.forEach((type, index) => {
                const shapeDiv = document.createElement('div');
                shapeDiv.classList.add('shape-item');
                shapeDiv.dataset.shapeType = type;
                shapeDiv.dataset.id = `t1_col1_${index}`;
                const svg = createShapeSvg(type, shapeSize);
                shapeDiv.appendChild(svg);
                shapeDiv.addEventListener('click', () => handleShapeConnectClickTask1(shapeDiv));
                col1Container.appendChild(shapeDiv);
                task1State.col1.push(shapeDiv);
            });
            column2ShapesData.forEach((type, index) => {
                const shapeDiv = document.createElement('div');
                shapeDiv.classList.add('shape-item');
                shapeDiv.dataset.shapeType = type;
                shapeDiv.dataset.id = `t1_col2_${index}`;
                const svg = createShapeSvg(type, shapeSize);
                shapeDiv.appendChild(svg);
                shapeDiv.addEventListener('click', () => handleShapeConnectClickTask1(shapeDiv));
                col2Container.appendChild(shapeDiv);
                task1State.col2.push(shapeDiv);
            });
        }
        function handleShapeConnectClickTask1(shapeDiv) {
            const svgLinesContainer = document.getElementById('connection_lines_svg_task1');
            const mainConnectArea = document.getElementById('connect_shapes_area');
            if (!mainConnectArea) return;
            const mainContainerRect = mainConnectArea.getBoundingClientRect();
            task1State.col1.forEach(s => s.classList.remove('correct-connection', 'incorrect-connection','selected'));
            task1State.col2.forEach(s => s.classList.remove('correct-connection', 'incorrect-connection','selected'));

            const existingConnectionIndex = task1State.connections.findIndex(conn => conn.from === shapeDiv || conn.to === shapeDiv);
            if (existingConnectionIndex !== -1) {
                const removedConn = task1State.connections.splice(existingConnectionIndex, 1)[0];
                if (removedConn && removedConn.line) removedConn.line.remove();
                if (task1State.selectedShape === shapeDiv) task1State.selectedShape = null;
                shapeDiv.classList.remove('selected');
                clearFeedback('feedback_task1');
                if (removedConn) {
                    const partner = removedConn.from === shapeDiv ? removedConn.to : removedConn.from;
                    if(partner) partner.classList.remove('selected');
                }
                return;
            }

            if (!task1State.selectedShape) {
                shapeDiv.classList.add('selected');
                task1State.selectedShape = shapeDiv;
                setFeedback('feedback_task1', "Válassz egy párt a másik oszlopból.", false);
            } else {
                if (task1State.selectedShape === shapeDiv) { 
                    task1State.selectedShape.classList.remove('selected');
                    task1State.selectedShape = null;
                    clearFeedback('feedback_task1');
                    return;
                }
                const isSelectedFromCol1 = task1State.col1.includes(task1State.selectedShape);
                const isCurrentFromCol2 = task1State.col2.includes(shapeDiv);
                const isSelectedFromCol2 = task1State.col2.includes(task1State.selectedShape);
                const isCurrentFromCol1 = task1State.col1.includes(shapeDiv);

                if (!((isSelectedFromCol1 && isCurrentFromCol2) || (isSelectedFromCol2 && isCurrentFromCol1))) {
                    setFeedback('feedback_task1', "Kérlek, a másik oszlopból válassz párt!", false);
                    return; 
                }
                const line = document.createElementNS(SVG_NS, 'line');
                const rect1 = task1State.selectedShape.getBoundingClientRect();
                const rect2 = shapeDiv.getBoundingClientRect();
                const x1 = rect1.left + rect1.width / 2 - mainContainerRect.left;
                const y1 = rect1.top + rect1.height / 2 - mainContainerRect.top;
                const x2 = rect2.left + rect2.width / 2 - mainContainerRect.left;
                const y2 = rect2.top + rect2.height / 2 - mainContainerRect.top;
                line.setAttribute('x1', x1); line.setAttribute('y1', y1);
                line.setAttribute('x2', x2); line.setAttribute('y2', y2);
                line.style.stroke = getThemeColor('--connection-line-color', '#6b7280');
                line.style.strokeWidth = '3';
                svgLinesContainer.appendChild(line);
                task1State.connections.push({ from: task1State.selectedShape, to: shapeDiv, line: line });
                task1State.selectedShape.classList.remove('selected');
                task1State.selectedShape = null;
                clearFeedback('feedback_task1');
            }
        }
        function checkTask1() {
            clearFeedback('feedback_task1');
            if (task1State.connections.length === 0) {
                setFeedback('feedback_task1', "Kérlek, köss össze legalább egy párt!", false); return;
            }
            let correctConnectionsCount = 0;
            const totalPossiblePairs = task1State.col1.length; 
            task1State.connections.forEach(conn => {
                const type1 = conn.from.dataset.shapeType;
                const type2 = conn.to.dataset.shapeType;
                conn.from.classList.remove('correct-connection', 'incorrect-connection');
                conn.to.classList.remove('correct-connection', 'incorrect-connection');
                if (type1 === type2) {
                    correctConnectionsCount++;
                    conn.line.style.stroke = getThemeColor('--feedback-correct-border-color', 'green');
                    conn.from.classList.add('correct-connection');
                    conn.to.classList.add('correct-connection');
                } else {
                    conn.line.style.stroke = getThemeColor('--feedback-incorrect-border-color', 'red');
                    conn.from.classList.add('incorrect-connection');
                    conn.to.classList.add('incorrect-connection');
                }
            });
            if (correctConnectionsCount === totalPossiblePairs && task1State.connections.length === totalPossiblePairs) {
                setFeedback('feedback_task1', `Szuper! Mind a ${totalPossiblePairs} kapcsolat helyes! 🎉`, true);
            } else if (correctConnectionsCount > 0 && task1State.connections.length < totalPossiblePairs) {
                 setFeedback('feedback_task1', `Helyes kapcsolatok: ${correctConnectionsCount}. Még ${totalPossiblePairs - task1State.connections.length} párt kell összekötnöd.`, false);
            } else if (correctConnectionsCount > 0) {
                 setFeedback('feedback_task1', `Helyes kapcsolatok: ${correctConnectionsCount} / ${task1State.connections.length}. Próbáld újra a hibásakat, vagy kösd össze a hiányzókat! (Összesen ${totalPossiblePairs} helyes pár van.)`, false);
            } else {
                 setFeedback('feedback_task1', `Sajnos egyik kapcsolat sem helyes. Próbáld újra! (Összesen ${totalPossiblePairs} helyes pár van.)`, false);
            }
        }

        let task2State = {};
        function generateTask2(isThemeChange = false) {
            if(!isThemeChange) clearFeedback('feedback_task2');
            const originalShapeDisplay = document.getElementById('shadow_original_shape_display');
            const shadowOptionsArea = document.getElementById('shadow_options_area');
            originalShapeDisplay.innerHTML = '';
            shadowOptionsArea.innerHTML = '';

            const shapeType = ALL_SHAPE_TYPES[Math.floor(Math.random() * ALL_SHAPE_TYPES.length)];
            task2State.correctShapeType = shapeType;
            task2State.selectedShadow = null;

            const originalSvg = createShapeSvg(shapeType, 80);
            originalShapeDisplay.appendChild(originalSvg);

            let options = [shapeType];
            let otherShapes = ALL_SHAPE_TYPES.filter(s => s !== shapeType);
            shuffleArray(otherShapes);
            for(let i=0; i < Math.min(2, otherShapes.length) ; i++) { 
                if(otherShapes[i]) options.push(otherShapes[i]);
            }
            shuffleArray(options);

            options.forEach((optType, index) => {
                const shadowDiv = document.createElement('div');
                shadowDiv.classList.add('shadow-item', 'shape-item');
                shadowDiv.dataset.shapeType = optType;
                const shadowSvg = createShapeSvg(optType, 70, { isShadow: true });
                shadowDiv.appendChild(shadowSvg);
                shadowDiv.addEventListener('click', () => handleShadowOptionClick(shadowDiv));
                shadowOptionsArea.appendChild(shadowDiv);
            });
        }
        function handleShadowOptionClick(clickedDiv) {
            document.querySelectorAll('#shadow_options_area .shadow-item').forEach(item => {
                item.classList.remove('selected', 'correct-selection', 'incorrect-selection');
            });
            clickedDiv.classList.add('selected');
            task2State.selectedShadow = clickedDiv;
            clearFeedback('feedback_task2');
        }
        function checkTask2() {
            if (!task2State.selectedShadow) {
                setFeedback('feedback_task2', "Kérlek, válassz egy árnyékot!", false);
                return;
            }
            const isCorrect = task2State.selectedShadow.dataset.shapeType === task2State.correctShapeType;
            task2State.selectedShadow.classList.remove('selected');
            task2State.selectedShadow.classList.add(isCorrect ? 'correct-selection' : 'incorrect-selection');
            setFeedback('feedback_task2', isCorrect ? "Helyes! Ez a jó árnyék! 👍" : "Ez nem a helyes árnyék. Próbáld újra!", isCorrect);
        }

        let task3State = {};
        function generateTask3(isThemeChange = false) {
            if(!isThemeChange) clearFeedback('feedback_task3');
            const draggableArea = document.getElementById('grouping_draggable_shapes_area');
            const bins = {
                kor: document.getElementById('grouping_bin_korok'),
                negyszog: document.getElementById('grouping_bin_negyszogek'),
                haromszog: document.getElementById('grouping_bin_haromszogek')
            };
            draggableArea.innerHTML = '';
            Object.values(bins).forEach(bin => {
                if(bin) {
                    Array.from(bin.children).forEach(child => {
                        if (child.classList.contains('shape-item')) child.remove();
                    });
                    bin.classList.remove('correct-bin', 'incorrect-bin');
                    bin.style.borderColor = getThemeColor('--bin-border-default', '#9ca3af'); 
                }
            });

            const shapesForTask3 = ALL_SHAPE_TYPES.filter(type =>
                SHAPE_CATEGORIES[type] === "kor" || SHAPE_CATEGORIES[type] === "negyszog" || SHAPE_CATEGORIES[type] === "haromszog"
            );
            if (shapesForTask3.length === 0) {
                 console.error("Nincsenek elérhető alakzatok a 3. feladathoz!"); return;
            }

            let shapesToGroupTypes = [];
            const numberOfShapesToGroup = 5 + Math.floor(Math.random() * 3); // 5-7 alakzat
            for(let i=0; i < numberOfShapesToGroup; i++){ 
                shapesToGroupTypes.push(shapesForTask3[Math.floor(Math.random() * shapesForTask3.length)]);
            }
            shuffleArray(shapesToGroupTypes);

            task3State.shapes = [];
            task3State.binContents = { kor: [], negyszog: [], haromszog: [] };


            shapesToGroupTypes.forEach((type, index) => {
                const shapeDiv = document.createElement('div');
                shapeDiv.classList.add('shape-item');
                shapeDiv.id = `group_shape_${index}`;
                shapeDiv.dataset.shapeType = type;
                shapeDiv.dataset.category = SHAPE_CATEGORIES[type]; 
                const svg = createShapeSvg(type, 50);
                shapeDiv.appendChild(svg);
                makeDraggable(shapeDiv, { type: type, category: SHAPE_CATEGORIES[type], id: shapeDiv.id, originalParentId: draggableArea.id });
                draggableArea.appendChild(shapeDiv);
                task3State.shapes.push({id: shapeDiv.id, type: type, category: SHAPE_CATEGORIES[type], currentBinCategory: null});
            });

            Object.entries(bins).forEach(([category, binElement]) => {
                if(binElement) makeDroppable(binElement, onDropToBinTask3);
            });
            makeDroppable(draggableArea, onDropToDraggableAreaTask3);
        }

        function onDropToBinTask3(draggedItem, binElement, data) {
            const shapeState = task3State.shapes.find(s => s.id === data.id);
            const targetBinCategory = binElement.dataset.category;

            if (shapeState) {
                if (shapeState.currentBinCategory && task3State.binContents[shapeState.currentBinCategory]) {
                    task3State.binContents[shapeState.currentBinCategory] = task3State.binContents[shapeState.currentBinCategory].filter(id => id !== data.id);
                }
                shapeState.currentBinCategory = targetBinCategory;
                if (!task3State.binContents[targetBinCategory]) task3State.binContents[targetBinCategory] = [];
                task3State.binContents[targetBinCategory].push(data.id);
            }
            binElement.appendChild(draggedItem);
            draggedItem.style.position = 'relative'; 
            draggedItem.style.left = '';
            draggedItem.style.top = '';
            clearFeedback('feedback_task3');
        }
        function onDropToDraggableAreaTask3(draggedItem, targetArea, data) { 
            const shapeState = task3State.shapes.find(s => s.id === data.id);
            if (shapeState && shapeState.currentBinCategory) {
                 task3State.binContents[shapeState.currentBinCategory] = task3State.binContents[shapeState.currentBinCategory].filter(id => id !== data.id);
                 shapeState.currentBinCategory = null;
            }
            targetArea.appendChild(draggedItem);
            clearFeedback('feedback_task3');
        }

        function checkTask3() {
            let allCorrect = true;
            let placedCount = 0;
            document.querySelectorAll('.grouping-bin').forEach(bin => {
                bin.classList.remove('correct-bin', 'incorrect-bin'); 
                bin.style.borderColor = getThemeColor('--bin-border-default', '#9ca3af'); 
                const binCategory = bin.dataset.category;
                const itemsInBin = Array.from(bin.children).filter(child => child.classList.contains('shape-item'));
                placedCount += itemsInBin.length;

                if (itemsInBin.length > 0) {
                    let binIsInternallyCorrect = true;
                    itemsInBin.forEach(item => {
                        if (item.dataset.category !== binCategory) {
                            binIsInternallyCorrect = false;
                            allCorrect = false; 
                        }
                    });
                    if (binIsInternallyCorrect) {
                         bin.style.borderColor = getThemeColor('--feedback-correct-border-color', 'green');
                    } else {
                         bin.style.borderColor = getThemeColor('--feedback-incorrect-border-color', 'red');
                    }
                }
            });

            const totalShapes = task3State.shapes.length;
            if (placedCount < totalShapes) {
                allCorrect = false; 
                setFeedback('feedback_task3', `Még nem minden alakzat van a dobozokban! Helyezd el a maradék ${totalShapes - placedCount} alakzatot is.`, false);
                return;
            }

            if (allCorrect) {
                setFeedback('feedback_task3', "Nagyon ügyes! Minden alakzat a helyén van! 🎉", true);
            } else {
                setFeedback('feedback_task3', "Néhány alakzat nincs a jó helyen. Nézd át a piros keretes dobozokat, vagy azokat, amikben nem megfelelő alakzat van!", false);
            }
        }


        let task4State = {};
        function generateTask4(isThemeChange = false) {
            if(!isThemeChange) clearFeedback('feedback_task4');
            const area = document.getElementById('odd_one_out_area');
            area.innerHTML = '';
            task4State.selectedShape = null;

            const commonShapesCount = 3 + Math.floor(Math.random() * 2); 
            const commonShapeType = ALL_SHAPE_TYPES[Math.floor(Math.random() * ALL_SHAPE_TYPES.length)];
            let oddShapeType;
            do {
                oddShapeType = ALL_SHAPE_TYPES[Math.floor(Math.random() * ALL_SHAPE_TYPES.length)];
            } while (oddShapeType === commonShapeType);

            task4State.oddOneOutType = oddShapeType;
            let shapesToDisplay = [];
            for(let i=0; i<commonShapesCount; i++) shapesToDisplay.push(commonShapeType);
            shapesToDisplay.push(oddShapeType);
            shuffleArray(shapesToDisplay);

            shapesToDisplay.forEach((type, index) => {
                const shapeDiv = document.createElement('div');
                shapeDiv.classList.add('shape-item');
                shapeDiv.dataset.shapeType = type;
                shapeDiv.id = `odd_shape_${index}`;
                const svg = createShapeSvg(type, 60);
                shapeDiv.appendChild(svg);
                shapeDiv.addEventListener('click', () => handleOddOneOutClick(shapeDiv));
                area.appendChild(shapeDiv);
            });
        }
        function handleOddOneOutClick(clickedDiv) {
            document.querySelectorAll('#odd_one_out_area .shape-item').forEach(item => {
                item.classList.remove('selected', 'correct-selection', 'incorrect-selection');
            });
            clickedDiv.classList.add('selected');
            task4State.selectedShape = clickedDiv;
            clearFeedback('feedback_task4');
        }
        function checkTask4() {
            if (!task4State.selectedShape) {
                setFeedback('feedback_task4', "Kérlek, válassz egy alakzatot!", false);
                return;
            }
            const isCorrect = task4State.selectedShape.dataset.shapeType === task4State.oddOneOutType;
             task4State.selectedShape.classList.remove('selected');
            task4State.selectedShape.classList.add(isCorrect ? 'correct-selection' : 'incorrect-selection');
            setFeedback('feedback_task4', isCorrect ? "Helyes! Ez volt a kakukktojás! 🥚" : "Ez az alakzat illik a sorba. Keresd meg azt, amelyik más!", isCorrect);
        }

        let task5State = {};
        function generateTask5(isThemeChange = false) {
            if(!isThemeChange) clearFeedback('feedback_task5');
            const sequenceArea = document.getElementById('sequence_display_area');
            const dropTarget = document.getElementById('sequence_drop_target');
            const optionsArea = document.getElementById('sequence_options_area');
            sequenceArea.innerHTML = '';
            dropTarget.innerHTML = '?';
            dropTarget.classList.remove('correct-choice', 'incorrect-choice');
            optionsArea.innerHTML = '';
            task5State.droppedShapeType = null;

            const typeA = ALL_SHAPE_TYPES[Math.floor(Math.random() * ALL_SHAPE_TYPES.length)];
            let typeB;
            do {
                typeB = ALL_SHAPE_TYPES[Math.floor(Math.random() * ALL_SHAPE_TYPES.length)];
            } while (typeB === typeA);

            const sequencePatternChoice = Math.random();
            let sequence = [];
            if (sequencePatternChoice < 0.5) { 
                sequence = [typeA, typeB, typeA];
                task5State.correctNext = typeB;
            } else { 
                sequence = [typeA, typeA, typeB, typeA, typeA];
                task5State.correctNext = typeB;
            }


            sequence.forEach(type => {
                const shapeDiv = document.createElement('div');
                shapeDiv.classList.add('shape-item', 'sequence-item-display');
                shapeDiv.appendChild(createShapeSvg(type, 50));
                sequenceArea.appendChild(shapeDiv);
            });

            let options = [task5State.correctNext];
            let wrongOptions = ALL_SHAPE_TYPES.filter(s => s !== task5State.correctNext && s !== typeA && s !== typeB);
            shuffleArray(wrongOptions);
            if(wrongOptions[0]) options.push(wrongOptions[0]);
            if(options.length < 3 && typeA !== task5State.correctNext) options.push(typeA); 

            while(options.length < 2 && wrongOptions.length > 1) options.push(wrongOptions.pop()); 
            if(options.length < 2) { 
                ALL_SHAPE_TYPES.forEach(s_type => {
                    if (options.length < 3 && !options.includes(s_type)) options.push(s_type);
                })
            }

            shuffleArray(options);

            options.slice(0,3).forEach((optType, index) => { 
                const optionDiv = document.createElement('div');
                optionDiv.classList.add('shape-item');
                optionDiv.id = `seq_opt_${index}`;
                optionDiv.dataset.shapeType = optType;
                optionDiv.appendChild(createShapeSvg(optType, 50));
                makeDraggable(optionDiv, { type: optType, id: optionDiv.id });
                optionDiv.addEventListener('click', () => {
                    dropTarget.innerHTML = '';
                    dropTarget.appendChild(createShapeSvg(optType, 70));
                    task5State.droppedShapeType = optType;
                     document.querySelectorAll('#sequence_options_area .shape-item').forEach(item => item.classList.remove('selected'));
                    optionDiv.classList.add('selected');
                    clearFeedback('feedback_task5');
                });
                optionsArea.appendChild(optionDiv);
            });
             makeDroppable(dropTarget, (draggedItem, target, data) => {
                target.innerHTML = '';
                target.appendChild(createShapeSvg(data.type, 70));
                task5State.droppedShapeType = data.type;
                clearFeedback('feedback_task5');
                 document.querySelectorAll('#sequence_options_area .shape-item').forEach(item => item.classList.remove('selected'));
                const originalOption = document.getElementById(data.id);
                if(originalOption) originalOption.classList.add('selected');
            });
        }
        function checkTask5() {
            const dropTarget = document.getElementById('sequence_drop_target');
            dropTarget.classList.remove('correct-choice', 'incorrect-choice');
            if (!task5State.droppedShapeType) {
                setFeedback('feedback_task5', "Kérlek, válassz vagy húzz egy alakzatot a kérdőjel helyére!", false);
                return;
            }
            const isCorrect = task5State.droppedShapeType === task5State.correctNext;
            dropTarget.classList.add(isCorrect ? 'correct-choice' : 'incorrect-choice');
            setFeedback('feedback_task5', isCorrect ? "Ügyes! Ez a helyes folytatás! 🏁" : "Nem ez következik a sorban. Figyelj jobban!", isCorrect);
        }

        let task7State = {};
        function generateTask7(isThemeChange = false) {
            if(!isThemeChange) clearFeedback('feedback_task7');
            const displayArea = document.getElementById('identify_shape_display_area');
            const optionsContainer = document.getElementById('identify_answer_options');
            displayArea.innerHTML = '';
            optionsContainer.innerHTML = '';
            task7State.selectedOption = null;

            const shapeType = ALL_SHAPE_TYPES[Math.floor(Math.random() * ALL_SHAPE_TYPES.length)];
            task7State.correctType = shapeType;
            displayArea.appendChild(createShapeSvg(shapeType, 90));

            let options = [shapeType];
            let otherTypes = ALL_SHAPE_TYPES.filter(s => s !== shapeType);
            shuffleArray(otherTypes);
            for(let i=0; i< Math.min(2, otherTypes.length); i++) { if(otherTypes[i]) options.push(otherTypes[i]); }
            shuffleArray(options);

            options.forEach(optType => {
                const button = document.createElement('button');
                button.classList.add('answer-option-button');
                button.textContent = SHAPE_NAMES[optType] || optType; 
                button.dataset.shapeType = optType;
                button.addEventListener('click', () => handleIdentifyOptionClick(button));
                optionsContainer.appendChild(button);
            });
        }
        function handleIdentifyOptionClick(clickedButton) {
            document.querySelectorAll('#identify_answer_options .answer-option-button').forEach(btn => {
                btn.classList.remove('selected', 'correct-choice', 'incorrect-choice');
            });
            clickedButton.classList.add('selected');
            task7State.selectedOption = clickedButton;
            clearFeedback('feedback_task7');
        }
        function checkTask7() {
            if (!task7State.selectedOption) {
                setFeedback('feedback_task7', "Kérlek, válassz egy megnevezést!", false);
                return;
            }
            const isCorrect = task7State.selectedOption.dataset.shapeType === task7State.correctType;
            task7State.selectedOption.classList.remove('selected');
            setFeedback('feedback_task7', isCorrect ? "Pontosan! Ez egy " + (SHAPE_NAMES[task7State.correctType] || task7State.correctType) + ". ✅" : "Ez nem a helyes név. Próbáld újra!", isCorrect);
        }

        let task8State = {};
        function generateTask8(isThemeChange = false) {
            if(!isThemeChange) clearFeedback('feedback_task8');
            const instructionEl = document.getElementById('color_task_instruction');
            const paletteArea = document.getElementById('color_palette_task8');
            const shapesArea = document.getElementById('coloring_shapes_area');
            paletteArea.innerHTML = '';
            shapesArea.innerHTML = '';

            task8State.targetShapeType = ALL_SHAPE_TYPES[Math.floor(Math.random() * ALL_SHAPE_TYPES.length)];
            task8State.targetColor = TASK8_COLORS[Math.floor(Math.random() * TASK8_COLORS.length)];
            task8State.selectedPaletteColor = null;
            task8State.coloredShapes = {}; 

            instructionEl.textContent = `Színezd ki az összes ${SHAPE_NAMES_PLURAL[task8State.targetShapeType] || task8State.targetShapeType+"-okat/eket"} ${task8State.targetColor.name} színűre!`;

            TASK8_COLORS.forEach(color => {
                const btn = document.createElement('button');
                btn.classList.add('color-palette-button');
                btn.style.backgroundColor = color.value;
                btn.dataset.colorValue = color.value;
                btn.dataset.colorName = color.name;
                btn.title = color.name;
                btn.addEventListener('click', () => {
                    task8State.selectedPaletteColor = color;
                    document.querySelectorAll('#color_palette_task8 .color-palette-button').forEach(b => b.classList.remove('selected-color'));
                    btn.classList.add('selected-color');
                });
                paletteArea.appendChild(btn);
            });

            let displayShapesTypes = [];
            displayShapesTypes.push(task8State.targetShapeType);
            displayShapesTypes.push(task8State.targetShapeType);

            let otherShapesForTask8 = ALL_SHAPE_TYPES.filter(s => s !== task8State.targetShapeType);
            shuffleArray(otherShapesForTask8);
            for(let i=0; i < Math.min(2, otherShapesForTask8.length); i++) { 
                if(otherShapesForTask8[i]) displayShapesTypes.push(otherShapesForTask8[i]);
            }
            shuffleArray(displayShapesTypes); 

            displayShapesTypes.forEach((type, index) => {
                const shapeDiv = document.createElement('div');
                shapeDiv.classList.add('colorable-shape','shape-item');
                shapeDiv.id = `color_shape_${index}`;
                shapeDiv.dataset.shapeType = type;
                const defaultShapeFill = getThemeColor('--shape-fill-default', '#eeeeee');
                shapeDiv.appendChild(createShapeSvg(type, 60, { fill: defaultShapeFill }));
                task8State.coloredShapes[shapeDiv.id] = defaultShapeFill; 

                shapeDiv.addEventListener('click', () => {
                    if (task8State.selectedPaletteColor) {
                        const svgEl = shapeDiv.querySelector('svg > *:not(text)'); 
                        if (svgEl) {
                            svgEl.setAttribute('fill', task8State.selectedPaletteColor.value);
                            task8State.coloredShapes[shapeDiv.id] = task8State.selectedPaletteColor.value;
                            shapeDiv.classList.remove('correct-color', 'incorrect-color'); 
                        }
                    } else {
                        setFeedback('feedback_task8', "Először válassz egy színt a palettáról!", false);
                    }
                });
                shapesArea.appendChild(shapeDiv);
            });
        }
        function checkTask8() {
            let allTargetsCorrectlyColored = true;
            let nonTargetsIncorrectlyColored = false;
            let targetShapesExist = false;

            document.querySelectorAll('#coloring_shapes_area .colorable-shape').forEach(shapeDiv => {
                shapeDiv.classList.remove('correct-color', 'incorrect-color');
                const shapeType = shapeDiv.dataset.shapeType;
                const currentColor = task8State.coloredShapes[shapeDiv.id];
                const defaultShapeFill = getThemeColor('--shape-fill-default', '#eeeeee');

                if (shapeType === task8State.targetShapeType) {
                    targetShapesExist = true;
                    if (currentColor === task8State.targetColor.value) {
                        shapeDiv.classList.add('correct-color');
                    } else {
                        shapeDiv.classList.add('incorrect-color');
                        allTargetsCorrectlyColored = false;
                    }
                } else { 
                    if (currentColor === task8State.targetColor.value) { 
                        shapeDiv.classList.add('incorrect-color');
                        nonTargetsIncorrectlyColored = true;
                    }
                }
            });

            if (!targetShapesExist) {
                 setFeedback('feedback_task8', "Hoppá, nem jelentek meg kiszínezendő alakzatok!", false); return;
            }

            if (allTargetsCorrectlyColored && !nonTargetsIncorrectlyColored) {
                setFeedback('feedback_task8', "Tökéletes színezés! 🎨", true);
            } else {
                setFeedback('feedback_task8', "Valami nem stimmel a színekkel. Ellenőrizd, hogy a megfelelő alakzatok vannak-e a kért színnel kiszínezve, és a többiek nem!", false);
            }
        }


        let task9State = {
            shapesInOrder: [],
            questionedShapeType: null, // Az alakzat típusa, amire rákérdezünk
            questionedShapeIndex: -1, // Az EGYETLEN ilyen típusú alakzat indexe
            correctPosFromLeft: 0,
            correctPosFromRight: 0
        };
        function generateTask9(isThemeChange = false) {
            if (!isThemeChange) clearFeedback('feedback_task9');
            const displayArea = document.getElementById('position_shapes_display_area');
            const instructionTextEl = document.getElementById('position_task_instruction_text');
            const inputLeftEl = document.getElementById('position_input_left');
            const inputRightEl = document.getElementById('position_input_right');

            displayArea.innerHTML = '';
            inputLeftEl.value = '';
            inputRightEl.value = '';
            inputLeftEl.classList.remove('correct-input', 'incorrect-input');
            inputRightEl.classList.remove('correct-input', 'incorrect-input');

            const numShapes = getRandomInt(5, 8);
            task9State.shapesInOrder = [];

            // 1. Válasszunk egy típust, amire rákérdezünk
            task9State.questionedShapeType = ALL_SHAPE_TYPES[Math.floor(Math.random() * ALL_SHAPE_TYPES.length)];

            // 2. Helyezzük el ezt a típust egyszer egy véletlen pozícióba
            task9State.questionedShapeIndex = Math.floor(Math.random() * numShapes);

            // 3. Töltsük fel a többi helyet MÁS típusú alakzatokkal
            for (let i = 0; i < numShapes; i++) {
                if (i === task9State.questionedShapeIndex) {
                    task9State.shapesInOrder.push(task9State.questionedShapeType);
                } else {
                    let randomOtherType;
                    do {
                        randomOtherType = ALL_SHAPE_TYPES[Math.floor(Math.random() * ALL_SHAPE_TYPES.length)];
                    } while (randomOtherType === task9State.questionedShapeType); // Ne legyen ugyanolyan, mint a kérdezett
                    task9State.shapesInOrder.push(randomOtherType);
                }
            }

            task9State.correctPosFromLeft = task9State.questionedShapeIndex + 1;
            task9State.correctPosFromRight = numShapes - task9State.questionedShapeIndex;

            const questionedShapeName = SHAPE_NAMES[task9State.questionedShapeType] || "alakzat";
            instructionTextEl.textContent = `Figyeld meg az alakzatokat! A sorban lévő ${questionedShapeName} balról és jobbról hanyadik?`;

            task9State.shapesInOrder.forEach((type, index) => {
                const shapeDiv = document.createElement('div');
                shapeDiv.classList.add('position-task-shape');
                // NEM adjuk hozzá a 'target-for-question' osztályt
                shapeDiv.appendChild(createShapeSvg(type, 60));
                displayArea.appendChild(shapeDiv);
            });

             inputLeftEl.max = numShapes;
             inputRightEl.max = numShapes;

             inputLeftEl.addEventListener('input', function() {
                inputLeftEl.classList.remove('correct-input', 'incorrect-input');
                if (this.value && this.value.length >= String(this.max).length && parseInt(this.value) <= parseInt(this.max)) {
                    document.getElementById('position_input_right').focus();
                }
            });
            inputRightEl.addEventListener('input', function() {
                inputRightEl.classList.remove('correct-input', 'incorrect-input');
            });
        }
        function checkTask9() {
            const inputLeftEl = document.getElementById('position_input_left');
            const inputRightEl = document.getElementById('position_input_right');

            const userAnswerLeft = parseInt(inputLeftEl.value);
            const userAnswerRight = parseInt(inputRightEl.value);

            let leftCorrect = false;
            let rightCorrect = false;
            let allFilledAndValid = true;

            if (isNaN(userAnswerLeft) || userAnswerLeft < 1 || userAnswerLeft > parseInt(inputLeftEl.max) ) {
                inputLeftEl.classList.add('incorrect-input');
                inputLeftEl.classList.remove('correct-input');
                allFilledAndValid = false;
            } else if (userAnswerLeft === task9State.correctPosFromLeft) {
                inputLeftEl.classList.add('correct-input');
                inputLeftEl.classList.remove('incorrect-input');
                leftCorrect = true;
            } else {
                inputLeftEl.classList.add('incorrect-input');
                inputLeftEl.classList.remove('correct-input');
            }

            if (isNaN(userAnswerRight) || userAnswerRight < 1 || userAnswerRight > parseInt(inputRightEl.max)) {
                inputRightEl.classList.add('incorrect-input');
                inputRightEl.classList.remove('correct-input');
                allFilledAndValid = false;
            } else if (userAnswerRight === task9State.correctPosFromRight) {
                inputRightEl.classList.add('correct-input');
                inputRightEl.classList.remove('incorrect-input');
                rightCorrect = true;
            } else {
                inputRightEl.classList.add('incorrect-input');
                inputRightEl.classList.remove('correct-input');
            }

            if (!allFilledAndValid && (isNaN(userAnswerLeft) || isNaN(userAnswerRight)) ) {
                setFeedback('feedback_task9', "Kérlek, mindkét helyre írj be egy számot!", false);
            } else if (!allFilledAndValid) {
                 setFeedback('feedback_task9', "Kérlek, érvényes sorszámokat adj meg!", false);
            }
            else if (leftCorrect && rightCorrect) {
                setFeedback('feedback_task9', "Helyes! Ügyesen meghatároztad a pozíciókat! 👍", true);
            } else {
                let errorMsg = "Nem tökéletes. ";
                if (!leftCorrect && (inputLeftEl.value !== "")) errorMsg += "A balról számolt sorszám nem jó. ";
                else if (inputLeftEl.value === "") errorMsg += "A balról számolt sorszám hiányzik. ";

                if (!rightCorrect && (inputRightEl.value !== "")) errorMsg += "A jobbról számolt sorszám nem jó. ";
                else if (inputRightEl.value === "") errorMsg += "A jobbról számolt sorszám hiányzik. ";

                errorMsg += "Próbáld újra!";
                setFeedback('feedback_task9', errorMsg, false);
            }
        }

        const BUILD_GOALS = {
            haziko: { name: "házikót", instruction: "Építs házikót a megadott alakzatokból!", required: { negyzet: 1, haromszog: 1 } },
            auto: { name: "autót", instruction: "Építs autót a megadott alakzatokból!", required: { teglalap: 1, kor: 2 } },
            sator: { name: "sátrat", instruction: "Építs sátrat a megadott alakzatból!", required: { haromszog: 1 } },
            var: { name: "várat", instruction: "Építs várat a megadott alakzatokból!", required: { negyzet: 1, teglalap: 1, haromszog: 2 } }
        };

        let task10State = {
            currentGoalKey: 'haziko',
            paletteShapes: ["kor", "negyzet", "haromszog", "teglalap", "otszog", "rombusz", "trapez"],
            placedShapes: []
        };

        function generateTask10(isThemeChange = false) {
            if(!isThemeChange) clearFeedback('feedback_task10');
            const paletteArea = document.getElementById('build_palette_task10');
            const canvasArea = document.getElementById('build_canvas_task10');
            const instructionEl = document.getElementById('build_task_instruction');
            paletteArea.innerHTML = '';
            canvasArea.innerHTML = '';
            task10State.placedShapes = [];

            const goalKeys = Object.keys(BUILD_GOALS);
            task10State.currentGoalKey = goalKeys[Math.floor(Math.random() * goalKeys.length)];
            const currentGoal = BUILD_GOALS[task10State.currentGoalKey];
            
            let requiredShapesList = [];
            for (const shapeType in currentGoal.required) {
                requiredShapesList.push(`${currentGoal.required[shapeType]} db ${SHAPE_NAMES[shapeType] || shapeType}`);
            }
            instructionEl.textContent = `${currentGoal.instruction} (Szükséges: ${requiredShapesList.join(', ')}.)`;


            if (!document.getElementById('build-task-styles')) {
                const style = document.createElement('style');
                style.id = 'build-task-styles';
                style.innerHTML = `
                    .build-area-container { display: flex; gap: 20px; margin-top: 20px; justify-content: center; flex-wrap: wrap;}
                    .build-palette { width: 150px; min-height: 250px; border: 2px dashed var(--task-border); padding: 10px; display: flex; flex-direction: column; align-items: center; gap: 10px; background-color: var(--task-bg); border-radius: 8px;}
                    .build-canvas { width: 300px; height: 250px; border: 2px solid var(--task-border); position: relative; background-color: var(--container-bg); border-radius: 8px; overflow: hidden;}
                    .build-palette .shape-item { cursor: grab !important; }
                    .build-canvas .shape-item { position: absolute !important; cursor: move !important; }
                `;
                document.head.appendChild(style);
            }
            
            // Paletta összeállítása: tartalmazza a szükségeseket + néhány extra véletlenszerűt
            let paletteSet = new Set();
            Object.keys(currentGoal.required).forEach(type => paletteSet.add(type));
            
            const extrasNeeded = Math.max(0, 4 - paletteSet.size); // Legyen legalább 4-5 elem a palettán
            let availableExtras = task10State.paletteShapes.filter(type => !paletteSet.has(type));
            shuffleArray(availableExtras);
            for(let i=0; i < Math.min(extrasNeeded, availableExtras.length); i++) {
                paletteSet.add(availableExtras[i]);
            }
            // Ha még mindig kevés, adjunk hozzá a teljes listából (ez ritka eset)
            if (paletteSet.size < 3) {
                shuffleArray(task10State.paletteShapes);
                for(const type of task10State.paletteShapes){
                    if(paletteSet.size >= 4) break;
                    paletteSet.add(type);
                }
            }

            let finalPalette = Array.from(paletteSet);
            shuffleArray(finalPalette);

            finalPalette.forEach((type, index) => {
                const shapeDiv = document.createElement('div');
                shapeDiv.classList.add('shape-item');
                shapeDiv.id = `build_palette_${type}_${index}`;
                shapeDiv.dataset.shapeType = type;
                shapeDiv.appendChild(createShapeSvg(type, 50));
                makeDraggable(shapeDiv, { type: type, id: shapeDiv.id, fromPalette: true });
                paletteArea.appendChild(shapeDiv);
            });

            makeDroppable(canvasArea, onDropToBuildCanvasTask10);
            makeDroppable(paletteArea, (draggedItem, targetPalette, data) => {
                if (!data.fromPalette) {
                    draggedItem.remove();
                    task10State.placedShapes = task10State.placedShapes.filter(s => s.id !== data.id);
                }
            });
        }
        function onDropToBuildCanvasTask10(draggedItem, targetCanvas, data) {
            const canvasRect = targetCanvas.getBoundingClientRect();
            let newX = event.clientX - canvasRect.left - (draggedItem.offsetWidth / 2);
            let newY = event.clientY - canvasRect.top - (draggedItem.offsetHeight / 2);
            newX = Math.max(0, Math.min(newX, canvasRect.width - draggedItem.offsetWidth));
            newY = Math.max(0, Math.min(newY, canvasRect.height - draggedItem.offsetHeight));

            if (data.fromPalette) {
                const clone = draggedItem.cloneNode(true);
                clone.style.position = 'absolute';
                clone.style.left = newX + 'px';
                clone.style.top = newY + 'px';
                clone.id = `built_shape_${Date.now()}_${Math.random().toString(36).substr(2, 5)}`;
                clone.dataset.shapeType = data.type;
                targetCanvas.appendChild(clone);
                task10State.placedShapes.push({id: clone.id, type: data.type, x: newX, y: newY});
                makeDraggable(clone, {type: data.type, id: clone.id, fromPalette: false});
            } else {
                draggedItem.style.left = newX + 'px';
                draggedItem.style.top = newY + 'px';
                const shapeState = task10State.placedShapes.find(s => s.id === data.id);
                if(shapeState) {
                    shapeState.x = newX;
                    shapeState.y = newY;
                }
            }
            clearFeedback('feedback_task10');
        }
        function checkTask10() {
            const currentGoal = BUILD_GOALS[task10State.currentGoalKey];
            const requiredShapesForGoal = currentGoal.required;

            const placedTypesCount = {};
            task10State.placedShapes.forEach(s => {
                placedTypesCount[s.type] = (placedTypesCount[s.type] || 0) + 1;
            });

            let allRequiredMet = true;
            for (const type in requiredShapesForGoal) {
                if ((placedTypesCount[type] || 0) < requiredShapesForGoal[type]) {
                    allRequiredMet = false;
                    break;
                }
            }
            
            if (allRequiredMet) {
                 setFeedback('feedback_task10', `Ügyes! Sikeresen felhasználtad a szükséges alakzatokat a ${currentGoal.name} építéséhez! 🎉`, true);
            } else {
                 let missingMsg = `Hiányoznak még elemek a ${currentGoal.name} építéséhez: `;
                 let missingParts = [];
                 for (const type in requiredShapesForGoal) {
                     const needed = requiredShapesForGoal[type];
                     const placed = placedTypesCount[type] || 0;
                     if (placed < needed) {
                         missingParts.push(`${needed - placed} db ${SHAPE_NAMES[type] || type}`);
                     }
                 }
                 setFeedback('feedback_task10', missingMsg + missingParts.join(', ') + ".", false);
            }
        }


        // --- INICIALIZÁLÁS ---
        document.addEventListener('DOMContentLoaded', function() {
            applyTheme(currentTheme);

            const initialGenerators = [
                generateTask1, generateTask2, generateTask3, generateTask4, generateTask5,
                generateTask7, generateTask8, generateTask9, generateTask10
            ];
            initialGenerators.forEach(genFunc => {
                if (typeof genFunc === 'function') {
                    try {
                        genFunc(false);
                    } catch(e) {
                        console.error("Hiba a kezdeti generáláskor (" + genFunc.name + "): ", e.message, e.stack);
                    }
                } else {
                    console.warn("Nem található generáló függvény: ", genFunc);
                }
            });
        });
    </script>
</body>
</html>